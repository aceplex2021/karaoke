# V4.8.0 Real-Time Migration Plan

**Version:** 4.8.0  
**Date:** 2026-01-21  
**Status:** Planning (Not Implemented)  
**Goal:** Replace all polling with Supabase real-time subscriptions to reduce Vercel invocations by ~99%

---

## Executive Summary

Currently, the Room page polls every 2.5 seconds, generating 24-44 API calls per minute per user. The TV page already uses real-time successfully. This migration will extend real-time to the Room page, eliminating ~99% of API calls.

**Current State:**
- Room page: 24-44 API calls/minute (polling)
- TV page: ✅ Real-time (already optimized)
- ApprovalQueue: 6-20 API calls/minute

**Target State:**
- Room page: ~1 API call per session (real-time)
- TV page: ✅ No change (already optimized)
- ApprovalQueue: ~1 API call per session (remove backup polling)

---

## ⚠️ CRITICAL POLICY: NO POLLING FALLBACK

**This migration eliminates polling completely. Key principles:**

1. **NO CACHING:**
   - All API calls use `cache: 'no-store'`
   - All headers include `'Cache-Control': 'no-cache'`
   - Already implemented in `src/lib/api.ts` - verify before proceeding

2. **NO CONTINUOUS POLLING FALLBACK:**
   - ❌ If real-time fails, DO NOT start continuous polling
   - ✅ Use retry logic (5 attempts, 5 second intervals)
   - ✅ After max retries, show user error message
   - ✅ If retry fails, full rollback to v4.7.7 (with polling)
   - **Why?** Continuous polling would defeat the purpose (99% reduction goal)

3. **METRIC PROTECTION:**
   - Vercel invocations MUST decrease by 95-99%
   - If invocations increase, immediate rollback required
   - Monitor Vercel dashboard first 24 hours

4. **ALL-OR-NOTHING:**
   - Either 100% real-time (with retry) OR full rollback
   - No hybrid "some real-time, some polling" approach

---

## Current State Analysis (Verified)

### ✅ Already Using Real-Time

#### 1. TV Page (`src/app/tv/page.tsx`)
- **Lines 280-335**: Real-time subscription implementation
- **Subscribes to:**
  - `kara_rooms` table (UPDATE events, line 291-305)
  - `kara_queue` table (all events, line 307-320)
- **Fallback:** 2.5s polling if real-time fails (line 344) - ⚠️ **TO BE REMOVED**
- **Status:** ✅ Working reliably in production
- **Action Required:** Update TV page to use retry logic instead of polling fallback

#### 2. ApprovalQueue Component (`src/components/ApprovalQueue.tsx`)
- **Lines 280-310**: Real-time subscription for participants
- **Subscribes to:**
  - `kara_room_participants` table (all events)
- **Fallback:** 3s polling if real-time fails (line 333)
- **Backup:** 10s polling even when real-time works (line 322) - **TO BE REMOVED**

### ❌ Currently Polling (Needs Migration)

#### Room Page (`src/app/room/[code]/page.tsx`)

**Polling #1: Room State (Line 612)**
```typescript
pollingIntervalRef.current = setInterval(() => {
  refreshRoomState(currentRoomId); // Calls api.getRoomState()
}, 2500); // Every 2.5 seconds
```
- **API Endpoint:** `/api/rooms/[roomId]/state`
- **Fetches:** room metadata, queue, upNext, currentSong
- **Impact:** 24 API calls/minute per active user

**Polling #2: Approval Status (Line 645)**
```typescript
approvalCheckIntervalRef.current = setInterval(async () => {
  const status = await checkApprovalStatus(roomId, userId); // Calls api.getUserStatus()
}, 3000); // Every 3 seconds
```
- **API Endpoint:** `/api/rooms/[roomId]/user-status`
- **Fetches:** User approval status (pending users only)
- **Impact:** 20 API calls/minute per pending user

---

## Supabase Capacity (Verified)

**Current Usage (from dashboard screenshot):**
- Realtime Concurrent Peak: **3/500** connections (<1%)
- Realtime Messages: **690/5,000,000** (<1%)
- **Result:** ✅ Plenty of capacity for migration

---

## Implementation Plan

### Phase 1: Room Page Real-Time Migration

#### Task 1.0: Verify NO CACHING (Critical)

**IMPORTANT:** Real-time updates MUST NOT use any caching.

**Verify in `src/lib/api.ts` (line 53-64):**
```typescript
async getRoomState(roomId: string): Promise<RoomState> {
  // ✅ CORRECT: No caching, fresh data always
  const res = await fetch(`${API_BASE}/rooms/${roomId}/state?t=${Date.now()}`, {
    cache: 'no-store',
    headers: {
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache'
    }
  });
  if (!res.ok) throw new Error('Failed to get room state');
  return res.json();
}
```

**Verify this is already implemented** - if not, update before proceeding.

---

#### Task 1.1: Add Real-Time Room/Queue Subscription

**File:** `src/app/room/[code]/page.tsx`

**Action:** Copy proven pattern from TV page (lines 280-335)

**CRITICAL:** Do NOT implement continuous polling fallback - use retry logic instead

**Add State:**
```typescript
const [useRealtime, setUseRealtime] = useState(true);
const realtimeChannelRef = useRef<RealtimeChannel | null>(null);
```

**Add Callback:**
```typescript
const subscribeToRoom = useCallback((roomId: string) => {
  if (realtimeChannelRef.current) {
    supabase.removeChannel(realtimeChannelRef.current);
    realtimeChannelRef.current = null;
  }

  const channel = supabase
    .channel(`room-${roomId}`)
    // Subscribe to room metadata changes
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'kara_rooms',
        filter: `id=eq.${roomId}`
      },
      (payload) => {
        console.log('[room] Realtime: Room updated', payload);
        refreshRoomState(roomId);
      }
    )
    // Subscribe to queue changes
    .on(
      'postgres_changes',
      {
        event: '*', // INSERT, UPDATE, DELETE
        schema: 'public',
        table: 'kara_queue',
        filter: `room_id=eq.${roomId}`
      },
      (payload) => {
        console.log('[room] Realtime: Queue updated', payload.eventType);
        refreshRoomState(roomId);
      }
    )
    .subscribe((status) => {
      console.log('[room] Realtime subscription status:', status);
      
      if (status === 'SUBSCRIBED') {
        console.log('[room] ✅ Realtime connected');
        // Stop any fallback polling if it was running
        if (pollingIntervalRef.current) {
          clearInterval(pollingIntervalRef.current);
          pollingIntervalRef.current = null;
        }
      } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
        console.error('[room] ❌ Realtime connection failed');
        // DO NOT start continuous polling - only retry real-time
        // This prevents increased Vercel invocations
        attemptRealtimeReconnect(roomId);
      }
    });
  
  realtimeChannelRef.current = channel;
}, [refreshRoomState, startPolling]);
```

**Integration:**
- Call `subscribeToRoom(roomId)` after initial room load
- Add cleanup in useEffect return

**Add Reconnection Strategy:**
```typescript
const reconnectAttemptsRef = useRef(0);
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY_MS = 5000; // 5 seconds between attempts

const attemptRealtimeReconnect = useCallback((roomId: string) => {
  reconnectAttemptsRef.current += 1;
  
  if (reconnectAttemptsRef.current > MAX_RECONNECT_ATTEMPTS) {
    console.error('[room] Max reconnection attempts reached. Real-time unavailable.');
    // DO NOT start polling - just show error to user
    // Polling would increase Vercel invocations which we want to avoid
    toast.error('Connection issues detected. Please refresh the page.');
    return;
  }
  
  console.log(`[room] Attempting real-time reconnection (${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS})`);
  
  setTimeout(() => {
    // Clean up old channel
    if (realtimeChannelRef.current) {
      supabase.removeChannel(realtimeChannelRef.current);
      realtimeChannelRef.current = null;
    }
    
    // Retry real-time subscription
    subscribeToRoom(roomId);
  }, RECONNECT_DELAY_MS);
}, [subscribeToRoom]);
```

**Remove:**
- Line 612: `setInterval` for room state polling (DELETE completely - no fallback polling)
- `startPolling()` function (DELETE - we rely 100% on real-time with retry logic)

---

#### Task 1.2: Add Real-Time User Status Subscription

**File:** `src/app/room/[code]/page.tsx`

**Action:** Add subscription for approval status changes

**Add Callback:**
```typescript
const subscribeToUserStatus = useCallback((roomId: string, userId: string) => {
  // Only subscribe if user is pending
  if (userApprovalStatus !== 'pending') {
    return;
  }

  const channel = supabase
    .channel(`user-status-${roomId}-${userId}`)
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'kara_room_participants',
        filter: `room_id=eq.${roomId} AND user_id=eq.${userId}`
      },
      (payload) => {
        console.log('[room] Realtime: User status updated', payload);
        const newStatus = payload.new?.status;
        if (newStatus) {
          setUserApprovalStatus(newStatus);
          
          // Stop subscription if approved or denied
          if (newStatus === 'approved' || newStatus === 'denied') {
            supabase.removeChannel(channel);
          }
        }
      }
    )
    .subscribe((status) => {
      console.log('[room] User status subscription:', status);
    });

  return channel;
}, [userApprovalStatus]);
```

**Integration:**
- Call when user joins room with pending status
- Stop subscription when status changes to approved/denied

**Remove:**
- Line 645: `setInterval` for approval polling

---

#### Task 1.3: Update useEffect Hook

**File:** `src/app/room/[code]/page.tsx`

**Current:**
```typescript
useEffect(() => {
  if (roomId) {
    startPolling(roomId);
  }
  return () => {
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
    }
  };
}, [roomId, startPolling]);
```

**New:**
```typescript
useEffect(() => {
  if (roomId) {
    if (useRealtime) {
      subscribeToRoom(roomId);
    } else {
      startPolling(roomId);
    }
  }
  
  return () => {
    // Cleanup polling
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
    
    // Cleanup real-time
    if (realtimeChannelRef.current) {
      supabase.removeChannel(realtimeChannelRef.current);
      realtimeChannelRef.current = null;
    }
  };
}, [roomId, useRealtime, subscribeToRoom, startPolling]);
```

---

### Phase 2: Update TV Page Real-Time (Remove Polling Fallback)

#### Task 2.0: Remove Polling Fallback from TV Page

**File:** `src/app/tv/page.tsx`

**Current Issue:** TV page currently falls back to polling if real-time fails (line 344)

**Action:** Replace polling fallback with retry logic (same as Room page)

**Update `subscribeToRoom` callback (line 322-332):**
```typescript
// BEFORE (line 328-331):
} else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
  console.error('[tv] ❌ Realtime failed, falling back to polling');
  setUseRealtime(false);
  startPolling(roomId); // ← REMOVE THIS
}

// AFTER:
} else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
  console.error('[tv] ❌ Realtime connection failed');
  // DO NOT start polling - retry real-time instead
  attemptRealtimeReconnect(roomId);
}
```

**Add retry logic** (same as Room page Task 1.1)

**Remove:** `startPolling()` function and polling interval code

---

### Phase 3: Optimize ApprovalQueue

#### Task 3.1: Remove ALL Polling from ApprovalQueue

**File:** `src/components/ApprovalQueue.tsx`

**Action:** Remove both backup polling (line 322) AND fallback polling (line 333)

**Current:**
```typescript
if (useRealtime) {
  subscribeToParticipants();
  // Still poll every 10s as backup ← REMOVE THIS
  const backupInterval = setInterval(() => fetchParticipants(), 10000);
  return () => {
    clearInterval(backupInterval);
    // ...
  };
} else {
  // Fallback: poll every 3 seconds ← REMOVE THIS TOO
  const interval = setInterval(() => fetchParticipants(), 3000);
  return () => clearInterval(interval);
}
```

**New:**
```typescript
if (useRealtime) {
  subscribeToParticipants();
  // No backup polling - 100% real-time
  return () => {
    if (realtimeChannelRef.current) {
      supabase.removeChannel(realtimeChannelRef.current);
      realtimeChannelRef.current = null;
    }
  };
} else {
  // If real-time fails, show error - NO polling
  console.error('[ApprovalQueue] Real-time unavailable');
  // Real-time failure would trigger full rollback to v4.7.7
  return () => {};
}
```

**Reason:** 
- Backup polling wastes 6 API calls/minute
- Fallback polling would defeat 99% reduction goal
- Real-time is proven reliable in TV page

---

### Phase 4: Testing & Verification

#### Task 4.1: Functional Testing

**Test Cases:**

1. **Real-Time Connection:**
   - [ ] Page loads → real-time connects within 2s
   - [ ] Console shows "✅ Realtime connected"
   - [ ] No polling intervals in Network tab

2. **Queue Updates:**
   - [ ] User A adds song → User B sees it instantly (<500ms)
   - [ ] User A removes song → User B sees update instantly
   - [ ] Host reorders song → All users see update instantly

3. **Room State Updates:**
   - [ ] Host skips song → All users see next song instantly
   - [ ] Queue mode changes → All users see update instantly

4. **Approval Flow:**
   - [ ] User joins (pending) → Host sees notification instantly
   - [ ] Host approves → User status updates instantly
   - [ ] Host denies → User sees denial instantly

5. **Reconnection Behavior:**
   - [ ] Simulate network disconnect → Attempts reconnection (5 retries)
   - [ ] Reconnect network → Restores real-time connection
   - [ ] Real-time error → Shows user error message (NO polling fallback)
   - [ ] Verify NO polling starts (check Network tab)

6. **Multi-User Stress Test:**
   - [ ] 5+ users in room
   - [ ] All add songs simultaneously
   - [ ] All users see all updates within 1s
   - [ ] No dropped events

---

#### Task 4.2: Performance Monitoring

**Metrics to Track:**

1. **Vercel Dashboard:**
   - [ ] Edge Function Invocations: Should drop ~95%
   - [ ] API call rate before: ~24-44/min per user
   - [ ] API call rate after: ~1 per user session
   - [ ] Monitor for 24 hours

2. **Supabase Dashboard:**
   - [ ] Realtime Concurrent Connections: Should stay <100 (well under 500 limit)
   - [ ] Realtime Messages: Should increase but stay <1% of 5M limit
   - [ ] No connection errors or timeouts

3. **Browser Performance:**
   - [ ] Network tab: Zero polling requests
   - [ ] Console: No error messages
   - [ ] Memory usage: No leaks (monitor over 30 min)
   - [ ] CPU usage: No high usage spikes

---

#### Task 4.3: Rollback Plan

**IMPORTANT:** No continuous polling fallback - only rollback to v4.7.7 if real-time fails

**If issues occur:**

1. **Code Rollback (ONLY Option):**
   - Git revert to v4.7.7: `git revert HEAD`
   - Deploy previous version (with polling)
   - Investigate issues offline
   - **Why no fallback?** Continuous polling would defeat the purpose of this migration

2. **Monitoring Triggers (Immediate Rollback):**
   - Realtime connection success rate <90%
   - User complaints about stale data
   - Supabase connection errors >5%
   - **Vercel invocations increase instead of decrease** ⚠️ CRITICAL
   - Users see "Connection issues" message frequently

3. **NOT ALLOWED:**
   - ❌ No automatic polling fallback
   - ❌ No environment variable toggle
   - ❌ Either 100% real-time OR full rollback to v4.7.7

---

## Expected Impact

### API Call Reduction

**Before (Current State):**
| Component | Frequency | Calls/Min | Endpoint |
|-----------|-----------|-----------|----------|
| Room state polling | 2.5s | 24 | `/api/rooms/[roomId]/state` |
| Approval polling | 3s | 20 | `/api/rooms/[roomId]/user-status` |
| ApprovalQueue backup | 10s | 6 | `/api/rooms/[roomId]/pending-users` |
| **Total per user** | - | **24-50** | - |

**After (Real-Time):**
| Component | Frequency | Calls/Session | Endpoint |
|-----------|-----------|---------------|----------|
| Initial room load | Once | 1 | `/api/rooms/[roomId]/state` |
| Real-time updates | WebSocket | 0 | Supabase real-time |
| **Total per user** | - | **~1** | - |

**Cost Savings:**
- **Per user:** 24-50 calls/min → 1 call/session
- **Reduction:** ~99%
- **Example:** 10 active users → 240-500 calls/min → 10 calls total (one-time)

---

### User Experience Improvements

**Before:**
- Updates appear every 2.5 seconds
- Noticeable delay when adding/removing songs
- Approval status checks every 3 seconds

**After:**
- Updates appear instantly (<500ms)
- Real-time queue changes
- Instant approval notifications
- Better perceived performance

---

### Infrastructure Impact

**Vercel:**
- ✅ 95-99% reduction in Edge Function invocations
- ✅ Lower bandwidth usage
- ✅ Reduced costs

**Supabase:**
- ⚠️ Increase in real-time connections (3 → ~50-100)
- ⚠️ Increase in real-time messages (~700 → ~10k/day)
- ✅ Still well within free tier limits (500 connections, 5M messages)

---

## Success Criteria

### Must Have (Blockers)
- [ ] Zero polling intervals after real-time connects
- [ ] **CRITICAL:** Zero polling intervals even if real-time fails (retry logic only)
- [ ] All queue/room updates appear within 500ms
- [ ] Approval status updates instantly for pending users
- [ ] **NO continuous polling fallback** - only retry real-time or rollback
- [ ] Network tab shows <5 API calls per user session (1 initial + retries only)
- [ ] Vercel invocations drop by 95-99% (NOT increase)
- [ ] No functional regressions from v4.7.7
- [ ] Real-time connection success rate >95%

### Nice to Have (Enhancements)
- [ ] Connection status indicator in UI
- [ ] Reconnection toast notification
- [ ] Real-time health metrics dashboard
- [ ] Automatic reconnection on network restore

---

## Risk Assessment

### High Risk (Mitigated)
1. **Real-time connection failures**
   - **Mitigation:** Automatic fallback to polling (proven in TV page)
   - **Test:** Simulate network failures

2. **Missed events during reconnection**
   - **Mitigation:** Full state refresh after reconnection
   - **Test:** Disconnect/reconnect stress test

### Medium Risk (Monitored)
1. **Supabase connection limits**
   - **Current:** 3/500 connections
   - **Expected:** <100/500 connections
   - **Monitoring:** Dashboard alerts if >400

2. **Message rate limits**
   - **Current:** 690/5M messages
   - **Expected:** <100k/5M messages
   - **Monitoring:** Dashboard alerts if >4M

### Low Risk
1. **Increased memory usage (WebSocket connections)**
   - **Impact:** Minimal (~5KB per connection)
   - **Browser limit:** 6 connections per domain (we use 1-2)

---

## Implementation Timeline

### Pre-Implementation
- [x] Complete codebase review
- [x] Document current state
- [x] Create detailed plan
- [x] Tag v4.7.7
- [x] Commit plan to git

### Phase 1: Room Page Migration (Estimated: 2-4 hours)
- [ ] Verify NO CACHING in api.ts
- [ ] Add real-time state management
- [ ] Add room/queue subscription with retry logic
- [ ] Add user status subscription
- [ ] REMOVE all polling code completely
- [ ] Test locally

### Phase 2: TV Page Update (Estimated: 1 hour)
- [ ] Replace polling fallback with retry logic
- [ ] REMOVE startPolling() function
- [ ] Test locally

### Phase 3: ApprovalQueue Optimization (Estimated: 30 min)
- [ ] Remove backup polling (10s)
- [ ] Remove fallback polling (3s)
- [ ] Test locally

### Phase 4: Testing (Estimated: 2-3 hours)
- [ ] Functional testing (all test cases)
- [ ] Verify ZERO polling in Network tab
- [ ] Performance monitoring (24 hours)
- [ ] Multi-user stress test
- [ ] Verify Vercel metrics DROP (not increase)

### Phase 5: Deployment (Estimated: 1 hour)
- [ ] Deploy to production
- [ ] Monitor Vercel dashboard (invocations must decrease)
- [ ] Monitor Supabase dashboard
- [ ] Verify user experience
- [ ] Ready to rollback to v4.7.7 if needed

---

## Rollback Strategy

**Trigger Conditions:**
- Realtime connection failure rate >10%
- API calls don't decrease by >90%
- User reports of stale data
- Console errors in production

**Rollback Steps:**
1. Revert git to v4.7.7: `git revert HEAD`
2. Deploy previous version
3. Verify polling restored
4. Investigate issues offline

**Communication:**
- Notify users of temporary revert
- Provide ETA for fix
- Document issues for next attempt

---

## Post-Implementation

### Monitoring (First 7 Days)
- [ ] Daily check of Vercel invocations
- [ ] Daily check of Supabase connections
- [ ] Monitor error logs
- [ ] Collect user feedback

### Documentation Updates
- [ ] Update README with real-time info
- [ ] Document troubleshooting steps
- [ ] Create real-time architecture diagram
- [ ] Add to release notes

### Future Enhancements
- [ ] Add connection status UI indicator
- [ ] Implement reconnection retry logic
- [ ] Add real-time analytics dashboard
- [ ] Optimize message batching

---

## Technical Reference

### Supabase Real-Time API

**Channel Creation:**
```typescript
const channel = supabase.channel('channel-name')
```

**Subscribe to Table Changes:**
```typescript
.on('postgres_changes', {
  event: 'INSERT' | 'UPDATE' | 'DELETE' | '*',
  schema: 'public',
  table: 'table_name',
  filter: 'column=eq.value'
}, (payload) => {
  // Handle change
})
```

**Subscribe & Handle Status:**
```typescript
.subscribe((status) => {
  if (status === 'SUBSCRIBED') {
    // Connected
  } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
    // Fallback to polling
  }
})
```

**Cleanup:**
```typescript
supabase.removeChannel(channel)
```

---

### Tables to Subscribe

**kara_rooms:**
- **Events:** UPDATE
- **Fields:** current_entry_id, queue_mode, is_active
- **Filter:** `id=eq.{roomId}`

**kara_queue:**
- **Events:** INSERT, UPDATE, DELETE (*)
- **Fields:** status, position, sort_key, round_number
- **Filter:** `room_id=eq.{roomId}`

**kara_room_participants:**
- **Events:** UPDATE
- **Fields:** status (pending, approved, denied)
- **Filter:** `room_id=eq.{roomId} AND user_id=eq.{userId}`

---

## Appendix

### Related Files
- `src/app/tv/page.tsx` - Reference implementation (lines 280-335)
- `src/app/room/[code]/page.tsx` - Target for migration
- `src/components/ApprovalQueue.tsx` - Backup polling removal
- `src/lib/api.ts` - API client (no changes needed)
- `src/lib/supabase.ts` - Supabase client (no changes needed)

### Git History
- **v4.7.7** - Current version (pre-migration)
- **v4.8.0** - This migration (planned)

### References
- [Supabase Realtime Docs](https://supabase.com/docs/guides/realtime)
- [TV Page Real-Time PR](https://github.com/...) - Original implementation
- [Vercel Function Pricing](https://vercel.com/pricing)
- [Supabase Pricing](https://supabase.com/pricing)

---

**Document Version:** 1.1  
**Last Updated:** 2026-01-21 (Updated)  
**Author:** AI Assistant  
**Status:** Planning Phase - Ready for Implementation

**v1.1 Changes:**
- ✅ Added CRITICAL POLICY: NO POLLING FALLBACK section
- ✅ Verified NO CACHING already implemented
- ✅ Replaced continuous polling fallback with retry logic (5 attempts, 5s intervals)
- ✅ Updated TV page to remove polling fallback
- ✅ Updated ApprovalQueue to remove ALL polling
- ✅ All-or-nothing approach: 100% real-time OR rollback to v4.7.7
- ✅ Updated success criteria to ensure Vercel metrics DECREASE
- ✅ Updated test cases to verify zero polling

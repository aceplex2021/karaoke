# v5.0 Implementation Plan: Authentication & Monetization
**Date**: 2026-01-24  
**Baseline**: v4.8 schema  
**Status**: Planning

---

## Overview

v5.0 adds user authentication and monetization while maintaining backward compatibility with v4.8. All v5.0 features are **toggle-enabled via environment variable** (`NEXT_PUBLIC_AUTH_MODE`), similar to the v4.0 transition.

**Core Features:**
1. **Authentication** - Supabase Auth (email/password, OAuth) to tie history/favorites to users and sync across all devices
2. **Monetization** - Stripe integration (subscriptions + one-time payments/a la carte)
3. **Database-driven pricing** - kara-pricing.md stored in database
4. **User-specific data** - History/favorites tied to auth user instead of device, syncs across all devices
5. **Feature toggle** - Seamless v4.8 ↔ v5.0 switching
6. **Landing page** - New landing page with pricing display and hamburger menu button (top left)
7. **Favorites without room** - Ability to add to Favorites without room connection (any authenticated user)
8. **Foreground playback** - Play favorites directly on user's device (bypasses TV/display layer) with custom play/pause/skip controls (Section 6.3)
9. **UI improvements** - Better step-by-step instructions on home page and detailed iOS/computer YouTube search instructions
10. **Native app (optional, last phase)** - Capacitor wrapper for iOS share sheet support (Android PWA already supports share sheet)

---

## Completed Work (Pre-v5.0)

### UI Improvements - Better Instructions (2026-01-24)

**Status**: ✅ **COMPLETED**

**What was done:**
- Home page: Replaced simple host/TV/user definitions with detailed step-by-step instructions
- Search tab: Added detailed iOS/computer YouTube search instructions
- Result: Users now have clear, step-by-step guidance reducing support calls

**Files Modified:**
- `src/app/page.tsx` - Home page instructions
- `src/app/room/[code]/page.tsx` - Search tab iOS/computer instructions

---

### Name Input Redundancy Fix (2026-01-24)

**Problem**: Users were asked to enter their name multiple times when joining rooms, inconsistently between Android and iOS/computer.

**Root Causes Identified**:
1. **localStorage key mismatch**: Join page stored name as `user_name`, but room page looked for `user_display_name`
2. **React Strict Mode**: Double execution in development caused iOS double-prompt
3. **No database fallback**: If localStorage was cleared, users had to re-enter name even if it existed in database

**Fixes Implemented**:

1. **Unified localStorage Key** (`src/app/join/page.tsx`)
   - Changed join page to store name as `user_display_name` (matching room page)
   - Result: No redundant prompt for users going through `/join` page

2. **React Strict Mode Guard** (`src/app/room/[code]/page.tsx`)
   - Added `hasCheckedNameRef` useRef guard to prevent double execution
   - Result: No double-prompt on iOS in development mode

3. **Database Fallback (Option B)** (`src/app/room/[code]/page.tsx`)
   - If name not in localStorage, check database via fingerprint
   - Uses client-side Supabase query (cost-optimized, no Vercel invocation)
   - Result: Returning users don't see modal even if localStorage cleared

4. **Backward Compatibility** (`src/app/room/[code]/page.tsx`)
   - Checks both `user_display_name` (correct) and `user_name` (legacy)
   - Result: Existing users with old key continue to work

**Files Modified**:
- `src/app/join/page.tsx` - Unified localStorage key
- `src/app/room/[code]/page.tsx` - Added React Strict Mode guard, database fallback, backward compatibility

**Cost Optimization**:
- **Original approach**: Created `/api/users/by-fingerprint/route.ts` (serverless function = Vercel invocation)
- **Optimized approach**: Use client-side Supabase query directly (0 Vercel invocations)
- **Result**: Eliminated serverless function calls for name lookup, reducing costs

**Note on `/api/users/by-fingerprint/route.ts`**:
- File exists but is **no longer used** (replaced by client-side Supabase query)
- Kept for future reference or v5.0 auth implementation
- Can be deleted if desired, or extended for v5.0 auth_user_id lookup

**Testing Checklist**:
- [x] Android: Enter name on join page → Auto-joins (no modal)
- [x] iOS: Enter name on join page → Auto-joins (no modal)
- [x] Direct access: Navigate to `/room/ABC123` directly → Shows modal (expected)
- [x] Returning user: Leave room, rejoin same room → Auto-joins (no modal)
- [x] Existing user (has `user_name` only): Works via fallback
- [x] User with localStorage cleared: Checks database → Auto-joins (no modal)

**Impact on v5.0**:
- This fix prepares the app for v5.0 authentication
- With auth, names will persist across devices automatically
- Database fallback logic will work seamlessly with `auth_user_id` lookup
- No modal for returning authenticated users

---

## Phase 1: Feature Toggle & Configuration

### 1.1 Environment Variables

**Add to `.env`:**
```env
# v5.0 Authentication & Monetization Toggle
NEXT_PUBLIC_AUTH_MODE=false  # false = v4.8 (device-based), true = v5.0 (auth required)

# Stripe Configuration (only used when AUTH_MODE=true)
STRIPE_SECRET_KEY=sk_test_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Supabase Auth (already exists, but ensure enabled)
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```

### 1.2 Update Configuration File

**File**: `src/lib/config.ts`

Add v5.0 configuration alongside existing v4.0 config:

```typescript
const isAuthMode = process.env.NEXT_PUBLIC_AUTH_MODE === 'true';

export const appConfig = {
  // Existing v4.0 fields...
  commercialMode: isCommercialMode,
  
  // NEW: v5.0 Auth & Monetization
  authMode: isAuthMode,
  
  features: {
    // Existing v4.0 features...
    databaseSearch: !isCommercialMode,
    youtubeSearch: isCommercialMode,
    
    // NEW: v5.0 features (only when authMode = true)
    authentication: isAuthMode,
    monetization: isAuthMode,
    subscriptions: isAuthMode,
    userAccounts: isAuthMode,
    
    // Behavior changes based on authMode
    deviceBasedAuth: !isAuthMode,  // v4.8: fingerprint-based
    accountBasedAuth: isAuthMode,  // v5.0: Supabase Auth-based
  },
  
  // NEW: v5.0 monetization config
  monetization: {
    enabled: isAuthMode,
    favoritesTrialDays: 30,
    roomPassDurationHours: 24,
  },
  
  // NEW: v5.0 Stripe config
  stripe: {
    publishableKey: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || '',
  },
};
```

### 1.3 Add Feature Check Helper

```typescript
/**
 * Check if v5.0 features are enabled
 */
export function isV5Enabled(): boolean {
  return appConfig.authMode;
}

/**
 * Get authentication strategy
 */
export function getAuthStrategy(): 'device' | 'account' {
  return isAuthMode ? 'account' : 'device';
}
```

### 1.4 Validation

Add startup validation:
```typescript
// Validate v5.0 configuration
if (isAuthMode) {
  if (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {
    warnings.push('⚠️ AUTH_MODE enabled but STRIPE_PUBLISHABLE_KEY missing');
  }
  if (!process.env.STRIPE_SECRET_KEY) {
    warnings.push('⚠️ AUTH_MODE enabled but STRIPE_SECRET_KEY missing');
  }
}
```

---

## Phase 2: Database Schema Migration

### 2.1 Pricing Configuration Table

**Purpose**: Store pricing from kara-pricing.md in database for easy updates

**File**: `database/v5.0_pricing_table.sql`

```sql
-- Pricing configuration (loaded from kara-pricing.md)
CREATE TABLE IF NOT EXISTS kara_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_type VARCHAR(50) NOT NULL UNIQUE,  -- 'room_pass_small', 'room_pass_party', 'favorites_lifetime', 'subscription_starter_monthly', etc.
  display_name VARCHAR(255) NOT NULL,
  description TEXT,
  price_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  duration_hours INTEGER,  -- For room passes (24)
  duration_days INTEGER,   -- For trials (30)
  user_limit INTEGER,      -- Max users per room (3 for small, NULL for unlimited)
  features JSONB DEFAULT '{}',  -- Additional features as JSON
  is_active BOOLEAN DEFAULT true,
  stripe_price_id VARCHAR(255),  -- Stripe Price ID
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_pricing_product_type ON kara_pricing(product_type);
CREATE INDEX idx_pricing_is_active ON kara_pricing(is_active);

-- Initial data from kara-pricing.md
INSERT INTO kara_pricing (product_type, display_name, description, price_cents, duration_hours, user_limit) VALUES
  ('room_pass_small', 'Small Room Pass (24 hours)', '≤3 singers, host 1 room, unlimited queue', 499, 24, 3),
  ('room_pass_party', 'Party Room Pass (24 hours)', 'Unlimited singers, host controls + reorder', 1299, 24, NULL),
  ('favorites_lifetime', 'Lifetime Favorites', 'Save unlimited songs forever, one-time purchase', 999, NULL, NULL),
  ('subscription_starter_monthly', 'Starter Monthly', '≤3 singers, room hosting anytime, unlimited favorites', 499, NULL, 3),
  ('subscription_starter_yearly', 'Starter Yearly', '≤3 singers, room hosting anytime, unlimited favorites', 4999, NULL, 3),
  ('subscription_party_monthly', 'Party Monthly', 'Unlimited singers, unlimited favorites', 699, NULL, NULL),
  ('subscription_party_yearly', 'Party Yearly', 'Unlimited singers, unlimited favorites', 6999, NULL, NULL);

-- Trial configuration
INSERT INTO kara_pricing (product_type, display_name, description, price_cents, duration_days, features) VALUES
  ('favorites_trial', 'Favorites Trial', '30 days free trial for favorites', 0, 30, '{"trial": true, "auto_start": true}');
```

**Benefits:**
- Update prices without redeployment
- A/B test pricing
- Easy to add/remove tiers
- Stripe Price ID mapping

### 2.2 User Subscriptions Table

**File**: `database/v5.0_subscriptions_table.sql`

```sql
-- User subscriptions (Stripe managed)
CREATE TABLE IF NOT EXISTS kara_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_customer_id VARCHAR(255) UNIQUE,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  
  -- Subscription details
  subscription_type VARCHAR(20) NOT NULL CHECK (subscription_type IN ('starter', 'party')),
  billing_interval VARCHAR(20) NOT NULL CHECK (billing_interval IN ('monthly', 'yearly')),
  status VARCHAR(20) NOT NULL CHECK (status IN ('active', 'canceled', 'past_due', 'trialing')),
  
  -- Stripe sync fields
  current_period_start TIMESTAMPTZ NOT NULL,
  current_period_end TIMESTAMPTZ NOT NULL,
  cancel_at_period_end BOOLEAN DEFAULT false,
  canceled_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_subscriptions_user_id ON kara_subscriptions(user_id);
CREATE INDEX idx_subscriptions_stripe_customer_id ON kara_subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON kara_subscriptions(status);

COMMENT ON TABLE kara_subscriptions IS 'v5.0: User-level subscriptions (starter or party)';
COMMENT ON COLUMN kara_subscriptions.user_id IS 'One subscription per user (UNIQUE constraint)';
```

### 2.3 Room Payments Table

**File**: `database/v5.0_room_payments_table.sql`

```sql
-- One-time room payments (24-hour passes)
CREATE TABLE IF NOT EXISTS kara_room_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID NOT NULL UNIQUE REFERENCES kara_rooms(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_payment_intent_id VARCHAR(255) UNIQUE NOT NULL,
  
  -- Payment details
  payment_type VARCHAR(20) NOT NULL CHECK (payment_type IN ('room_pass_small', 'room_pass_party')),
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'succeeded', 'failed', 'refunded')),
  
  -- Room pass metadata
  expires_at TIMESTAMPTZ NOT NULL,  -- Auto-calculated: created_at + 24 hours
  user_limit INTEGER,  -- 3 for small, NULL for party
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_room_payments_room_id ON kara_room_payments(room_id);
CREATE INDEX idx_room_payments_user_id ON kara_room_payments(user_id);
CREATE INDEX idx_room_payments_status ON kara_room_payments(status);
CREATE INDEX idx_room_payments_expires_at ON kara_room_payments(expires_at);

COMMENT ON TABLE kara_room_payments IS 'v5.0: One-time 24-hour room passes';
COMMENT ON COLUMN kara_room_payments.room_id IS 'One payment per room (UNIQUE constraint)';
```

### 2.4 Favorites Purchases Table

**File**: `database/v5.0_favorites_purchases_table.sql`

```sql
-- Lifetime favorites purchases
CREATE TABLE IF NOT EXISTS kara_favorites_purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_payment_intent_id VARCHAR(255) UNIQUE NOT NULL,
  
  -- Purchase details
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'succeeded', 'failed', 'refunded')),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_favorites_purchases_user_id ON kara_favorites_purchases(user_id);
CREATE INDEX idx_favorites_purchases_status ON kara_favorites_purchases(status);

COMMENT ON TABLE kara_favorites_purchases IS 'v5.0: One-time lifetime favorites purchases';
COMMENT ON COLUMN kara_favorites_purchases.user_id IS 'One purchase per user (UNIQUE constraint)';
```

### 2.5 Favorites Trial Tracking

**File**: `database/v5.0_favorites_trials_table.sql`

```sql
-- Favorites trial tracking (30-day free trial)
CREATE TABLE IF NOT EXISTS kara_favorites_trials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Trial lifecycle
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,  -- started_at + 30 days
  
  -- Trial status
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'expired', 'converted')),
  
  -- First favorite saved (triggers trial start)
  first_favorite_song_id TEXT NOT NULL,
  
  -- Conversion tracking
  converted_to VARCHAR(50),  -- 'lifetime' or 'subscription' or NULL
  converted_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_favorites_trials_user_id ON kara_favorites_trials(user_id);
CREATE INDEX idx_favorites_trials_expires_at ON kara_favorites_trials(expires_at);
CREATE INDEX idx_favorites_trials_status ON kara_favorites_trials(status);

COMMENT ON TABLE kara_favorites_trials IS 'v5.0: 30-day favorites trial tracking (auto-starts on first save)';
```

### 2.6 Update Existing Tables

**File**: `database/v5.0_update_existing_tables.sql`

```sql
-- Add payment/subscription columns to kara_rooms
ALTER TABLE kara_rooms 
  ADD COLUMN IF NOT EXISTS payment_id UUID REFERENCES kara_room_payments(id) ON DELETE SET NULL;

ALTER TABLE kara_rooms
  ADD COLUMN IF NOT EXISTS payment_type VARCHAR(20) 
  CHECK (payment_type IN ('subscription', 'room_pass', NULL));

CREATE INDEX IF NOT EXISTS idx_rooms_payment_id ON kara_rooms(payment_id);

-- Add constraint: 1 active room per user
CREATE UNIQUE INDEX IF NOT EXISTS idx_rooms_one_active_per_user 
  ON kara_rooms(host_id) WHERE is_active = true;

-- Add subscription fields to kara_user_preferences
ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS subscription_id UUID REFERENCES kara_subscriptions(id) ON DELETE SET NULL;

ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS favorites_access_type VARCHAR(20)
  CHECK (favorites_access_type IN ('trial', 'lifetime', 'subscription', NULL));

ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS favorites_access_expires_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_user_prefs_subscription_id ON kara_user_preferences(subscription_id);
CREATE INDEX IF NOT EXISTS idx_user_prefs_favorites_access ON kara_user_preferences(favorites_access_type, favorites_access_expires_at);

COMMENT ON COLUMN kara_user_preferences.favorites_access_type IS 'How user has favorites access: trial, lifetime purchase, or subscription';
COMMENT ON COLUMN kara_user_preferences.favorites_access_expires_at IS 'NULL for lifetime, timestamp for trial/subscription';
```

---

## Phase 3: Authentication System

### 3.0 Supabase Auth Architecture

**Key Concept**: Supabase Auth uses `auth.users` (read-only), your app uses `kara_users` (editable)

**Relationship:**
```
auth.users (Supabase Auth - READ ONLY)
  ├─ id (UUID) ←──┐
  ├─ email         │
  ├─ providers     │
  └─ metadata      │
                   │ auth_user_id (FK)
                   │
kara_users (Your App - READ/WRITE)
  ├─ id (UUID) ────┘
  ├─ auth_user_id (UUID) → references auth.users.id
  ├─ fingerprint (for anonymous users)
  ├─ display_name
  └─ ... (app-specific data)
```

**How it works:**
1. User signs in via Supabase Auth (Google, GitHub, Email, Apple) → creates/updates `auth.users` record
2. Your app creates/updates `kara_users` record with `auth_user_id = auth.users.id`
3. All app queries use `kara_users` table
4. When you need auth data (email, providers), query `auth.users` via `auth_user_id`

**Benefits:**
- ✅ Keep app data separate from auth data
- ✅ Can edit `kara_users` without touching Supabase's managed `auth.users`
- ✅ Support both authenticated (`auth_user_id`) and anonymous (`fingerprint`) users
- ✅ Easy migration: link existing `fingerprint` users to `auth_user_id` when they sign up

**Query Examples:**

```sql
-- Get kara_users by Supabase Auth ID
SELECT * FROM kara_users WHERE auth_user_id = 'uuid-from-auth.users';

-- Join to get both auth and app data (if needed)
SELECT 
  ku.*,
  au.email,
  au.raw_user_meta_data
FROM kara_users ku
LEFT JOIN auth.users au ON ku.auth_user_id = au.id
WHERE ku.auth_user_id = 'uuid-from-auth.users';
```

**Important Notes:**
- ❌ **Never write to `auth.users`** - it's managed by Supabase Auth
- ✅ **Always write to `kara_users`** - this is your app's user table
- ✅ **Use `auth_user_id` to link** - this is the foreign key relationship
- ✅ **Support both modes**: authenticated users have `auth_user_id`, anonymous users have `fingerprint`

### 3.1 Supabase Auth Setup

**Enable Providers in Supabase Dashboard:**
1. Go to Supabase Dashboard → Authentication → Providers
2. Enable:
   - ✅ Email (already enabled)
   - ✅ Google OAuth
   - ✅ GitHub OAuth
   - ✅ Apple OAuth (requires Apple Developer account setup)
3. Configure OAuth redirect URLs:
   - Development: `http://localhost:3000/auth/callback`
   - Production: `https://yourdomain.com/auth/callback`

**Apple OAuth Setup (if needed):**
- Requires Apple Developer account ($99/year)
- Create Service ID in Apple Developer Portal
- Configure callback URL in Supabase
- See: https://supabase.com/docs/guides/auth/social-login/auth-apple

**Goal**: Enable email/password + OAuth (Google, etc.)

#### 3.1.1 Enable Auth in Supabase Dashboard
1. Go to Authentication → Providers
2. Enable Email/Password
3. Enable Google OAuth (optional)
4. Configure redirect URLs:
   - `http://localhost:3000/auth/callback` (dev)
   - `https://yourdomain.com/auth/callback` (prod)

#### 3.1.2 Auth Context Provider

**File**: `src/contexts/AuthContext.tsx`

```typescript
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { User as SupabaseUser } from '@supabase/supabase-js';
import { supabaseClient } from '@/lib/supabase-client';
import { User } from '@/shared/types';
import { appConfig } from '@/lib/config';

interface AuthContextType {
  supabaseUser: SupabaseUser | null;
  karaUser: User | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, displayName: string) => Promise<void>;
  signOut: () => Promise<void>;
  signInWithGoogle: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [supabaseUser, setSupabaseUser] = useState<SupabaseUser | null>(null);
  const [karaUser, setKaraUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // Only initialize if AUTH_MODE is enabled
  const isEnabled = appConfig.authMode;

  useEffect(() => {
    if (!isEnabled) {
      setLoading(false);
      return;
    }

    // Get initial session
    supabaseClient.auth.getSession().then(({ data: { session } }) => {
      setSupabaseUser(session?.user ?? null);
      if (session?.user) {
        loadKaraUser(session.user.id);
      } else {
        setLoading(false);
      }
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabaseClient.auth.onAuthStateChange((_event, session) => {
      setSupabaseUser(session?.user ?? null);
      if (session?.user) {
        loadKaraUser(session.user.id);
      } else {
        setKaraUser(null);
        setLoading(false);
      }
    });

    return () => subscription.unsubscribe();
  }, [isEnabled]);

  async function loadKaraUser(authUserId: string) {
    try {
      // Load kara_users record linked to this auth.users.id
      // This is your app's user data (editable), not auth.users (read-only)
      const response = await fetch(`/api/users/by-auth/${authUserId}`);
      if (response.ok) {
        const data = await response.json();
        setKaraUser(data.user);
      }
    } catch (error) {
      console.error('Failed to load kara user:', error);
    } finally {
      setLoading(false);
    }
  }

  async function signIn(email: string, password: string) {
    const { error } = await supabaseClient.auth.signInWithPassword({
      email,
      password,
    });
    if (error) throw error;
  }

  async function signUp(email: string, password: string, displayName: string) {
    // 1. Create Supabase auth user
    const { data, error } = await supabaseClient.auth.signUp({
      email,
      password,
      options: {
        data: {
          display_name: displayName,
        },
      },
    });
    if (error) throw error;

    // 2. Create or update kara_users entry linked to auth.users
    // IMPORTANT: auth.users is read-only, so we store app data in kara_users
    if (data.user) {
      await fetch('/api/users/create-from-auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          auth_user_id: data.user.id,  // Link to auth.users.id (Supabase Auth)
          display_name: displayName,
          email: data.user.email,
        }),
      });
    }
  }

  async function signOut() {
    await supabaseClient.auth.signOut();
  }

  async function signInWithGoogle() {
    await supabaseClient.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`,
      },
    });
  }

  return (
    <AuthContext.Provider
      value={{
        supabaseUser,
        karaUser,
        loading,
        signIn,
        signUp,
        signOut,
        signInWithGoogle,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 3.2 Auth Context Provider

**Key Implementation Notes:**

1. **Get Auth User from Supabase:**
   ```typescript
   const { data: { session } } = await supabase.auth.getSession();
   const authUserId = session?.user?.id;  // This is auth.users.id (read-only)
   ```

2. **Get App User (kara_users) from auth_user_id:**
   ```typescript
   const { data: karaUser } = await supabase
     .from('kara_users')
     .select('*')
     .eq('auth_user_id', authUserId)
     .single();
   ```

3. **Why we query kara_users, not auth.users:**
   - `auth.users` is read-only (can't add custom fields)
   - `kara_users` has all app-specific data (display_name, preferences, etc.)
   - `auth_user_id` links them together

### 3.3 Auth Pages

#### 3.2.1 Login Page

**File**: `src/app/login/page.tsx`

```typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import { appConfig } from '@/lib/config';

export default function LoginPage() {
  const router = useRouter();
  const { signIn, signInWithGoogle, loading } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  // Redirect to home if AUTH_MODE is disabled
  if (!appConfig.authMode) {
    router.push('/');
    return null;
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError('');
    try {
      await signIn(email, password);
      router.push('/');
    } catch (err: any) {
      setError(err.message || 'Failed to sign in');
    }
  }

  async function handleGoogleSignIn() {
    try {
      await signInWithGoogle();
    } catch (err: any) {
      setError(err.message || 'Failed to sign in with Google');
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-6 text-center">Sign In to Kara</h1>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
          >
            {loading ? 'Signing In...' : 'Sign In'}
          </button>
        </form>

        <div className="mt-4">
          <button
            onClick={handleGoogleSignIn}
            disabled={loading}
            className="w-full bg-white border border-gray-300 text-gray-700 py-2 rounded-lg hover:bg-gray-50"
          >
            Sign In with Google
          </button>
        </div>

        <p className="mt-4 text-center text-sm">
          Don't have an account?{' '}
          <a href="/signup" className="text-blue-600 hover:underline">
            Sign Up
          </a>
        </p>
      </div>
    </div>
  );
}
```

#### 3.2.2 Signup Page

**File**: `src/app/signup/page.tsx` (similar structure, calls `signUp`)

### 3.4 Migration Strategy: Device → Account

**Goal**: Smoothly migrate existing device-based users to account-based users

#### 3.4.1 Linking API Endpoint

**File**: `src/app/api/users/link-device-to-account/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/server/lib/supabase';

/**
 * POST /api/users/link-device-to-account
 * Links existing device-based user to authenticated account
 */
export async function POST(request: NextRequest) {
  try {
    const { auth_user_id, fingerprint } = await request.json();

    // Find existing device-based user
    const { data: deviceUser } = await supabaseAdmin
      .from('kara_users')
      .select('*')
      .eq('fingerprint', fingerprint)
      .single();

    if (deviceUser) {
      // Link existing user to auth account
      await supabaseAdmin
        .from('kara_users')
        .update({ auth_user_id })
        .eq('id', deviceUser.id);

      return NextResponse.json({ 
        success: true, 
        user: { ...deviceUser, auth_user_id },
        message: 'History and favorites preserved' 
      });
    } else {
      // Create new kara_users record linked to auth.users account
      // This is for users who sign up without prior anonymous usage
      const { data: newUser } = await supabaseAdmin
        .from('kara_users')
        .insert({ 
          auth_user_id,  // Link to auth.users.id
          fingerprint    // Keep fingerprint for device tracking
        })
        .select()
        .single();

      return NextResponse.json({ 
        success: true, 
        user: newUser,
        message: 'New account created' 
      });
    }
  } catch (error) {
    console.error('Link device to account error:', error);
    return NextResponse.json({ error: 'Failed to link account' }, { status: 500 });
  }
}
```

#### 3.4.2 Auto-Prompt on First Login

When user signs in for the first time, check for device fingerprint and offer to link:

```typescript
// In AuthContext after successful login
const fingerprint = localStorage.getItem('user_fingerprint');
if (fingerprint) {
  await fetch('/api/users/link-device-to-account', {
    method: 'POST',
    body: JSON.stringify({ auth_user_id: session.user.id, fingerprint }),
  });
}
```

---

## Phase 4: Stripe Integration

**Reuse Strategy**: Copy Stripe integration code from your existing project. Only need to:
1. Change API keys (connect to different Stripe account/bank account)
2. Adapt database table names to match this project's schema
3. Keep all Stripe API logic identical

**Effort Reduction**: From 3 days → **1-2 days** (reuse existing code)

### 4.1 Install Dependencies

```bash
npm install stripe @stripe/stripe-js
```

### 4.2 Import Stripe Code from Existing Project

**Step-by-Step Reuse Guide:**

**Note**: This project uses **Supabase Edge Functions** (Deno) for payment processing instead of Next.js API routes. This provides:
- ✅ Faster execution (edge-optimized)
- ✅ Better security (server-side only, no exposure to client)
- ✅ Less testing needed (reuse proven code)
- ✅ Direct Supabase integration

#### Files to Copy from Your Other Project:

1. **Stripe Frontend Client** (`src/lib/stripe-client.ts`)
   ```typescript
   // Copy as-is, only change environment variable
   // Your project might use: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
   // This project uses: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY (same)
   ```

2. **Checkout Session Creation Edge Function** (`src/stripe/create-stripe-session/index.ts`)
   - Copy entire Deno Edge Function file
   - **Adapt**: Change parameters from `tournament_id, member_id, amount` to `user_id, product_type`
   - **Adapt**: Fetch pricing from `kara_pricing` table (not hardcoded `amount`)
   - **Adapt**: Database table names:
     ```typescript
     // Your project: tournaments, members, tournament_payments
     // This project: kara_users, kara_pricing, kara_room_payments, kara_favorites_purchases
     ```
   - **Adapt**: Metadata fields:
     ```typescript
     metadata: {
       user_id,        // Instead of member_id
       product_type,   // Instead of tournament_id
       room_id,        // Optional, for room passes
     }
     ```

3. **Webhook Handler Edge Function** (`src/stripe/webhook-handler/index.ts`)
   - Copy entire Deno Edge Function file
   - **Adapt**: Database table names:
     ```typescript
     // Your project: tournament_payments, members
     // This project: kara_subscriptions, kara_room_payments, kara_favorites_purchases, kara_users
     ```
   - **Adapt**: Add handlers for:
     - `customer.subscription.updated` → Update `kara_subscriptions`
     - `customer.subscription.deleted` → Cancel `kara_subscriptions`
     - Enhanced `checkout.session.completed` → Handle subscriptions, room passes, favorites purchases

4. **CORS Shared Utilities** (`src/stripe/_shared/cors.ts`)
   - Copy as-is
   - **Adapt**: Update `ALLOWED_ORIGINS` to include this project's domains:
     ```typescript
     const ALLOWED_ORIGINS = [
       'http://localhost:3000',           // Local development
       'https://your-production-domain.com',  // Production
       // Add any other domains you need
     ];
     ```

5. **Payment Components** (if any)
   - Copy payment modal/checkout components
   - Adapt to this project's UI structure
   - Update API calls to use Edge Function URLs instead of Next.js routes

#### What to Change:

| Item | Your Project | This Project | Action |
|------|--------------|--------------|--------|
| **API Keys** | `sk_live_...` (old account) | `sk_live_...` (new account) | ✅ Change in `.env` |
| **Publishable Key** | `pk_live_...` (old account) | `pk_live_...` (new account) | ✅ Change in `.env` |
| **Webhook Secret** | `whsec_...` (old account) | `whsec_...` (new account) | ✅ Change in `.env` |
| **Database Tables** | Your table names | `kara_subscriptions`, `kara_room_payments`, etc. | ✅ Adapt in webhook handlers |
| **User ID Field** | Your user_id format | `user_id` (UUID) | ✅ Verify format matches |

#### What Stays the Same:

- ✅ Stripe API calls (`stripe.checkout.sessions.create`, etc.)
- ✅ Webhook event types (`checkout.session.completed`, `subscription.updated`, etc.)
- ✅ Frontend Stripe.js integration (`loadStripe`, `redirectToCheckout`)
- ✅ Error handling patterns
- ✅ Webhook signature verification logic

#### Quick Migration Checklist:

```bash
# 1. Copy Edge Functions from your other project
cp /path/to/other-project/src/stripe/create-stripe-session/index.ts ./src/stripe/create-stripe-session/
cp /path/to/other-project/src/stripe/webhook-handler/index.ts ./src/stripe/webhook-handler/
cp /path/to/other-project/src/stripe/_shared/cors.ts ./src/stripe/_shared/

# 2. Copy frontend Stripe client
cp /path/to/other-project/src/lib/stripe-client.ts ./src/lib/

# 3. Update .env with new Stripe account keys
# STRIPE_SECRET_KEY=sk_live_... (new account)
# NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_... (new account)
# STRIPE_WEBHOOK_SECRET=whsec_... (new account)

# 4. Update Supabase Edge Function secrets:
# supabase secrets set STRIPE_SECRET_KEY=sk_live_...
# supabase secrets set STRIPE_WEBHOOK_SECRET=whsec_...

# 5. Find and replace database table names in Edge Functions:
# tournaments → kara_pricing (for pricing lookup)
# members → kara_users
# tournament_payments → kara_room_payments or kara_favorites_purchases
# Add: kara_subscriptions (for subscription handling)

# 6. Deploy Edge Functions to Supabase:
# supabase functions deploy create-stripe-session
# supabase functions deploy webhook-handler

# 7. Test with Stripe test mode first
```

### 4.3 Stripe Client (Frontend)

**File**: `src/lib/stripe-client.ts`

```typescript
import { loadStripe } from '@stripe/stripe-js';
import { appConfig } from './config';

// Copy from your other project, just use new publishable key
let stripePromise: Promise<any> | null = null;

export function getStripe() {
  if (!appConfig.monetization.enabled) {
    return null;
  }

  if (!stripePromise) {
    stripePromise = loadStripe(appConfig.stripe.publishableKey);
  }
  return stripePromise;
}
```

### 4.4 Pricing API Endpoint (Next.js Route)

**Note**: Pricing endpoint can remain as Next.js route since it's read-only and doesn't handle sensitive payment data.

**File**: `src/app/api/pricing/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/server/lib/supabase';
import { appConfig } from '@/lib/config';

/**
 * GET /api/pricing
 * Returns active pricing from database
 */
export async function GET() {
  // Return empty if monetization disabled
  if (!appConfig.monetization.enabled) {
    return NextResponse.json({ pricing: [] });
  }

  const { data: pricing, error } = await supabaseAdmin
    .from('kara_pricing')
    .select('*')
    .eq('is_active', true)
    .order('price_cents', { ascending: true });

  if (error) {
    return NextResponse.json({ error: 'Failed to fetch pricing' }, { status: 500 });
  }

  return NextResponse.json({ pricing });
}
```

### 4.5 Create Checkout Session (Supabase Edge Function)

**File**: `src/stripe/create-stripe-session/index.ts`

**Reuse Strategy:**
- Copy Edge Function from your other project
- Adapt parameters: `tournament_id, member_id, amount` → `user_id, product_type`
- Fetch pricing from `kara_pricing` table instead of hardcoded amount
- Support both `subscription` and `payment` modes
- Adapt database tables to `kara_*` schema

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.47.12'
import Stripe from 'https://esm.sh/stripe@13.10.0'
import { corsHeaders, handleCors } from '../_shared/cors.ts'

const supabaseClient = createClient(
  Deno.env.get('SUPABASE_URL') || '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''
)

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2023-10-16'
})

serve(async (req) => {
  // Handle CORS preflight
  const corsResponse = handleCors(req);
  if (corsResponse) return corsResponse;

  try {
    const { product_type, user_id, room_id, success_url, cancel_url } = await req.json()

    if (!product_type || !user_id) {
      throw new Error('Missing required parameters: product_type, user_id')
    }

    // Get pricing from database (kara_pricing table)
    const { data: pricing, error: pricingError } = await supabaseClient
      .from('kara_pricing')
      .select('*')
      .eq('product_type', product_type)
      .eq('is_active', true)
      .single()

    if (pricingError || !pricing) {
      throw new Error('Invalid product type or pricing not found')
    }

    // Get user info (kara_users table)
    const { data: user, error: userError } = await supabaseClient
      .from('kara_users')
      .select('id, display_name, email')
      .eq('id', user_id)
      .single()

    if (userError || !user) {
      throw new Error('User not found')
    }

    // Determine payment mode
    const isSubscription = product_type.includes('subscription')
    const mode = isSubscription ? 'subscription' : 'payment'

    // Create payment record if room pass (for tracking)
    let paymentRecord = null
    if (product_type.includes('room_pass') && room_id) {
      const { data: existingPayment } = await supabaseClient
        .from('kara_room_payments')
        .select()
        .eq('room_id', room_id)
        .eq('user_id', user_id)
        .single()

      if (existingPayment?.status === 'succeeded') {
        throw new Error('Room already has active payment')
      }

      // Create pending payment record
      const { data: newPayment, error: paymentError } = await supabaseClient
        .from('kara_room_payments')
        .insert({
          room_id,
          user_id,
          payment_type: product_type,
          amount_cents: pricing.price_cents,
          currency: pricing.currency || 'USD',
          status: 'pending',
        })
        .select()
        .single()

      if (paymentError) throw paymentError
      paymentRecord = newPayment
    }

    // Create Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      mode,
      line_items: [
        {
          price_data: {
            currency: (pricing.currency || 'USD').toLowerCase(),
            product_data: {
              name: pricing.display_name,
              description: pricing.description || '',
            },
            unit_amount: pricing.price_cents,
            ...(isSubscription && {
              recurring: {
                interval: product_type.includes('monthly') ? 'month' : 'year',
              },
            }),
          },
          quantity: 1,
        },
      ],
      success_url: success_url || `${req.headers.get('origin')}/?payment=success&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: cancel_url || `${req.headers.get('origin')}/?payment=cancel`,
      metadata: {
        user_id,
        product_type,
        ...(room_id && { room_id }),
        ...(paymentRecord && { payment_id: paymentRecord.id }),
      },
      customer_email: user.email || undefined,
      expires_at: Math.floor(Date.now() / 1000) + (30 * 60) // 30 minutes
    })

    // Update payment record with session info (if room pass)
    if (paymentRecord) {
      const { error: updateError } = await supabaseClient
        .from('kara_room_payments')
        .update({
          stripe_session_id: session.id,
          stripe_session_url: session.url,
        })
        .eq('id', paymentRecord.id)

      if (updateError) throw updateError
    }

    return new Response(
      JSON.stringify({
        stripe_session_id: session.id,
        stripe_session_url: session.url,
        payment_id: paymentRecord?.id || null
      }),
      { 
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json'
        } 
      }
    )

  } catch (error) {
    console.error('Payment session error:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 400, 
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json'
        } 
      }
    )
  }
})
```

### 4.6 Stripe Webhooks (Supabase Edge Function)

**File**: `src/stripe/webhook-handler/index.ts`

**Reuse Strategy:**
- Copy Edge Function from your other project
- Keep event handling logic (checkout.session.completed, subscription.updated, etc.)
- **Adapt**: Database table names and field mappings:
  - `tournament_payments` → `kara_room_payments` or `kara_favorites_purchases`
  - `members` → `kara_users`
  - Add: `kara_subscriptions` (for subscription handling)
  - Add: `kara_user_preferences` (for favorites access updates)
- Keep webhook signature verification (just use new `STRIPE_WEBHOOK_SECRET`)

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.47.12'
import Stripe from 'https://esm.sh/stripe@14.25.0?target=denonext'
import { corsHeaders } from '../_shared/cors.ts'

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2023-10-16'
})

const endpointSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET')

const supabaseClient = createClient(
  Deno.env.get('SUPABASE_URL') || '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''
)

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      headers: {
        ...corsHeaders, 
        'Access-Control-Allow-Headers': 'stripe-signature, content-type'
      }
    })
  }

  try {
    const rawBody = await req.text()
    const signature = req.headers.get('stripe-signature')
    
    let event: Stripe.Event

    // Verify webhook signature
    try {
      event = await stripe.webhooks.constructEventAsync(
        rawBody,
        signature,
        endpointSecret
      )
    } catch (err) {
      console.error('Webhook signature verification failed:', err.message)
      return new Response(
        JSON.stringify({ error: `Webhook Error: ${err.message}` }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Log event info
    console.log('Processing webhook event:', {
      id: event.id,
      type: event.type,
      metadata: event.data.object.metadata
    })

    // Handle different event types
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session)
        break
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription)
        break
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription)
        break
      case 'payment_intent.succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent)
        break
    }

    return new Response(
      JSON.stringify({ received: true }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (err) {
    console.error('Webhook handler error:', err)
    return new Response(
      JSON.stringify({ error: err.message }),
      { 
        status: 400, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})

// Webhook handlers - adapt database calls to kara_* tables:

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const metadata = session.metadata || {}
  const { user_id, product_type, room_id, payment_id } = metadata

  if (!user_id || !product_type) {
    console.error('Missing user_id or product_type in metadata')
    return
  }

  // Handle subscriptions
  if (product_type.includes('subscription')) {
    const subscriptionType = product_type.includes('party') ? 'party' : 'starter'
    const billingInterval = product_type.includes('monthly') ? 'monthly' : 'yearly'
    
    // Calculate period end
    const periodStart = new Date()
    const periodEnd = new Date()
    if (billingInterval === 'monthly') {
      periodEnd.setMonth(periodEnd.getMonth() + 1)
    } else {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1)
    }

    // Create subscription record in kara_subscriptions
    const { error: subError } = await supabaseClient
      .from('kara_subscriptions')
      .insert({
        user_id,
        stripe_customer_id: session.customer as string,
        stripe_subscription_id: session.subscription as string,
        subscription_type: subscriptionType,
        billing_interval: billingInterval,
        status: 'active',
        current_period_start: periodStart.toISOString(),
        current_period_end: periodEnd.toISOString(),
        cancel_at_period_end: false,
      })

    if (subError) {
      console.error('Failed to create subscription:', subError)
      throw subError
    }

    // Update user preferences for favorites access
    await supabaseClient
      .from('kara_user_preferences')
      .upsert({
        user_id,
        subscription_id: session.subscription as string,
        favorites_access_type: 'subscription',
        favorites_access_expires_at: periodEnd.toISOString(),
      }, { onConflict: 'user_id' })

  } 
  // Handle room passes (24-hour passes)
  else if (product_type.includes('room_pass')) {
    if (!payment_id) {
      console.error('Missing payment_id for room pass')
      return
    }

    // Calculate expiry (24 hours from now)
    const expiresAt = new Date()
    expiresAt.setHours(expiresAt.getHours() + 24)

    // Update room payment record
    const { error: paymentError } = await supabaseClient
      .from('kara_room_payments')
      .update({
        status: 'succeeded',
        stripe_payment_intent_id: session.payment_intent as string,
        expires_at: expiresAt.toISOString(),
        payment_date: new Date().toISOString(),
      })
      .eq('id', payment_id)

    if (paymentError) {
      console.error('Failed to update room payment:', paymentError)
      throw paymentError
    }

    // Link payment to room if room_id provided
    if (room_id) {
      await supabaseClient
        .from('kara_rooms')
        .update({
          payment_id,
          payment_type: 'room_pass',
        })
        .eq('id', room_id)
    }
  } 
  // Handle favorites lifetime purchase
  else if (product_type === 'favorites_lifetime') {
    // Create favorites purchase record
    const { error: purchaseError } = await supabaseClient
      .from('kara_favorites_purchases')
      .insert({
        user_id,
        stripe_payment_intent_id: session.payment_intent as string,
        amount_cents: session.amount_total || 0,
        currency: session.currency || 'USD',
        status: 'succeeded',
      })

    if (purchaseError) {
      console.error('Failed to create favorites purchase:', purchaseError)
      throw purchaseError
    }

    // Update user preferences for lifetime access
    await supabaseClient
      .from('kara_user_preferences')
      .upsert({
        user_id,
        favorites_access_type: 'lifetime',
        favorites_access_expires_at: null, // NULL = lifetime
      }, { onConflict: 'user_id' })
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  // Update subscription status and period
  const { error } = await supabaseClient
    .from('kara_subscriptions')
    .update({
      status: subscription.status,
      current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
      current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
      cancel_at_period_end: subscription.cancel_at_period_end,
    })
    .eq('stripe_subscription_id', subscription.id)

  if (error) {
    console.error('Failed to update subscription:', error)
    throw error
  }

  // Update user preferences if subscription is active
  if (subscription.status === 'active') {
    const periodEnd = new Date(subscription.current_period_end * 1000)
    await supabaseClient
      .from('kara_user_preferences')
      .update({
        favorites_access_type: 'subscription',
        favorites_access_expires_at: periodEnd.toISOString(),
      })
      .eq('user_id', subscription.metadata?.user_id)
  }
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  // Cancel subscription
  const { error } = await supabaseClient
    .from('kara_subscriptions')
    .update({ 
      status: 'canceled', 
      canceled_at: new Date().toISOString() 
    })
    .eq('stripe_subscription_id', subscription.id)

  if (error) {
    console.error('Failed to cancel subscription:', error)
    throw error
  }

  // Remove favorites access if no other access type
  const { data: userPrefs } = await supabaseClient
    .from('kara_user_preferences')
    .select('*')
    .eq('user_id', subscription.metadata?.user_id)
    .single()

  // Only remove if subscription was the only access type
  if (userPrefs?.favorites_access_type === 'subscription') {
    await supabaseClient
      .from('kara_user_preferences')
      .update({
        favorites_access_type: null,
        favorites_access_expires_at: null,
      })
      .eq('user_id', subscription.metadata?.user_id)
  }
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  // This is a fallback handler for payment_intent.succeeded
  // Most logic is handled in checkout.session.completed
  // Use this for additional verification if needed
  
  const metadata = paymentIntent.metadata || {}
  const { user_id, product_type } = metadata

  if (!user_id || !product_type) return

  // Log successful payment
  console.log('Payment succeeded:', {
    payment_intent_id: paymentIntent.id,
    user_id,
    product_type,
    amount: paymentIntent.amount
  })
}
```

---

### 4.7 Frontend Integration (Calling Edge Functions)

**How to call Edge Functions from frontend:**

Edge Functions are deployed to Supabase and accessible via:
```
https://<project-ref>.supabase.co/functions/v1/<function-name>
```

**Example: Create Checkout Session from Frontend**

```typescript
// In your pricing/checkout component
import { getStripe } from '@/lib/stripe-client';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

async function handleCheckout(productType: string, userId: string, roomId?: string) {
  try {
    // Call Edge Function to create checkout session
    const { data, error } = await supabase.functions.invoke('create-stripe-session', {
      body: {
        product_type: productType,
        user_id: userId,
        room_id: roomId, // Optional, for room passes
        success_url: `${window.location.origin}/?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${window.location.origin}/?payment=cancel`,
      },
    });

    if (error) throw error;

    // Redirect to Stripe Checkout
    const stripe = await getStripe();
    if (stripe && data.stripe_session_url) {
      window.location.href = data.stripe_session_url;
      // Or use Stripe.js redirectToCheckout:
      // const { error: redirectError } = await stripe.redirectToCheckout({
      //   sessionId: data.stripe_session_id,
      // });
      // if (redirectError) throw redirectError;
    }
  } catch (error) {
    console.error('Checkout error:', error);
    alert('Failed to start checkout. Please try again.');
  }
}
```

**Alternative: Direct fetch to Edge Function**

```typescript
async function handleCheckout(productType: string, userId: string) {
  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/create-stripe-session`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`,
        },
        body: JSON.stringify({
          product_type: productType,
          user_id: userId,
          success_url: `${window.location.origin}/?payment=success`,
          cancel_url: `${window.location.origin}/?payment=cancel`,
        }),
      }
    );

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to create checkout');
    }

    // Redirect to Stripe Checkout
    if (data.stripe_session_url) {
      window.location.href = data.stripe_session_url;
    }
  } catch (error) {
    console.error('Checkout error:', error);
  }
}
```

**Webhook Configuration:**

1. **Deploy Edge Function:**
   ```bash
   supabase functions deploy webhook-handler
   ```

2. **Get Edge Function URL:**
   ```
   https://<project-ref>.supabase.co/functions/v1/webhook-handler
   ```

3. **Configure in Stripe Dashboard:**
   - Go to Stripe Dashboard → Developers → Webhooks
   - Add endpoint: `https://<project-ref>.supabase.co/functions/v1/webhook-handler`
   - Select events:
     - `checkout.session.completed`
     - `customer.subscription.updated`
     - `customer.subscription.deleted`
     - `payment_intent.succeeded`
   - Copy webhook signing secret to `STRIPE_WEBHOOK_SECRET` environment variable

4. **Set Supabase Secrets:**
   ```bash
   supabase secrets set STRIPE_SECRET_KEY=sk_live_...
   supabase secrets set STRIPE_WEBHOOK_SECRET=whsec_...
   ```

---

## Phase 5: Business Logic & Enforcement

### 5.1 Room Creation with Payment Check

**File**: `src/app/api/rooms/create/route.ts` (update existing)

```typescript
export async function POST(request: NextRequest) {
  const { room_name, host_fingerprint, host_display_name } = await request.json();
  
  // v5.0: Check if AUTH_MODE is enabled
  if (appConfig.authMode) {
    // AUTH_MODE: Require authentication
    const authHeader = request.headers.get('authorization');
    if (!authHeader) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }
    
    // Extract user from JWT
    const user = await getUserFromToken(authHeader);
    
    // Check if user has active subscription or valid room pass
    const hasAccess = await checkRoomAccess(user.id);
    if (!hasAccess) {
      return NextResponse.json({ 
        error: 'Payment required',
        redirect: '/pricing'
      }, { status: 402 });
    }
    
    // Check: Only 1 active room per user
    const { data: existingRoom } = await supabaseAdmin
      .from('kara_rooms')
      .select('id')
      .eq('host_id', user.id)
      .eq('is_active', true)
      .single();
    
    if (existingRoom) {
      return NextResponse.json({ 
        error: 'You already have an active room. Close it first.',
        room_id: existingRoom.id
      }, { status: 400 });
    }
    
    // Create room...
  } else {
    // v4.8 mode: Device-based (existing logic)
    // ... existing room creation code
  }
}

async function checkRoomAccess(userId: string): Promise<boolean> {
  // Check active subscription
  const { data: subscription } = await supabaseAdmin
    .from('kara_subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .single();
  
  if (subscription) return true;
  
  // Check valid room pass (not expired)
  const { data: roomPass } = await supabaseAdmin
    .from('kara_room_payments')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'succeeded')
    .gt('expires_at', new Date().toISOString())
    .single();
  
  return !!roomPass;
}
```

### 5.2 Favorites Access Check

**File**: `src/app/api/users/[userId]/favorites/route.ts` (update existing)

```typescript
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  const { song_id } = await request.json();
  
  // v5.0: Check favorites access (any authenticated user can add, no room required)
  if (appConfig.authMode) {
    const hasAccess = await checkFavoritesAccess(params.userId);
    
    if (!hasAccess.canSave) {
      return NextResponse.json({ 
        error: hasAccess.reason,
        upsell: hasAccess.upsell
      }, { status: 402 });
    }
  }
  
  // Add to favorites (no room_id required - can add without room connection)
  // Note: Room context is optional, favorites are user-global
  // Background playback is host-only (checked separately in playback endpoint)
}

async function checkFavoritesAccess(userId: string) {
  // Check lifetime purchase
  const { data: lifetime } = await supabaseAdmin
    .from('kara_favorites_purchases')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'succeeded')
    .single();
  
  if (lifetime) {
    return { canSave: true, canAdd: true };
  }
  
  // Check active subscription
  const { data: subscription } = await supabaseAdmin
    .from('kara_subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .single();
  
  if (subscription) {
    return { canSave: true, canAdd: true };
  }
  
  // Check trial
  const { data: trial } = await supabaseAdmin
    .from('kara_favorites_trials')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .gt('expires_at', new Date().toISOString())
    .single();
  
  if (trial) {
    return { canSave: true, canAdd: true, trial: true };
  }
  
  // No access
  return { 
    canSave: false, 
    canAdd: false,
    reason: 'Favorites trial expired',
    upsell: {
      lifetime: 999,
      subscription_monthly: 499
    }
  };
}
```

### 5.3 Trial Auto-Start

**File**: `src/app/api/users/[userId]/favorites/start-trial/route.ts`

```typescript
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  try {
    const { first_favorite_song_id } = await request.json();
    
    // Check if trial already exists
    const { data: existing } = await supabaseAdmin
      .from('kara_favorites_trials')
      .select('*')
      .eq('user_id', params.userId)
      .single();
    
    if (existing) {
      return NextResponse.json({ trial: existing });
    }
    
    // Create 30-day trial
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30);
    
    const { data: trial } = await supabaseAdmin
      .from('kara_favorites_trials')
      .insert({
        user_id: params.userId,
        first_favorite_song_id,
        expires_at: expiresAt.toISOString(),
        status: 'active',
      })
      .select()
      .single();
    
    return NextResponse.json({ 
      trial,
      message: 'Favorites Trial Started 🎉',
      days_remaining: 30
    });
  } catch (error) {
    console.error('Start trial error:', error);
    return NextResponse.json({ error: 'Failed to start trial' }, { status: 500 });
  }
}
```

---

## Phase 6: Frontend UI Components

### 6.1 Landing Page with Pricing

**File**: `src/app/page.tsx` (update existing)

**Features:**
- **Hamburger menu button** (top left) - Navigation menu with:
  - Home
  - Pricing
  - Account/Settings (if authenticated)
  - Login/Signup (if not authenticated)
  - Logout (if authenticated)
- **Pricing display** - Show pricing cards directly on landing page
  - Room passes (Small/Party)
  - Subscriptions (Starter/Party, Monthly/Yearly)
  - Lifetime Favorites
- **Call-to-action buttons** - "Get Started", "View Pricing", etc.
- **Responsive design** - Mobile-friendly layout

**Implementation:**
```typescript
// Hamburger menu component
<HamburgerMenu>
  <MenuItem href="/">Home</MenuItem>
  <MenuItem href="/pricing">Pricing</MenuItem>
  {isAuthenticated ? (
    <>
      <MenuItem href="/account">Account</MenuItem>
      <MenuItem onClick={signOut}>Logout</MenuItem>
    </>
  ) : (
    <>
      <MenuItem href="/login">Login</MenuItem>
      <MenuItem href="/signup">Sign Up</MenuItem>
    </>
  )}
</HamburgerMenu>

// Pricing section on landing page
<PricingSection>
  <PricingCard type="room_pass_small" />
  <PricingCard type="room_pass_party" />
  <PricingCard type="subscription_starter_monthly" />
  <PricingCard type="subscription_party_monthly" />
  <PricingCard type="favorites_lifetime" />
</PricingSection>
```

### 6.2 Favorites Without Room Connection

**File**: `src/app/favorites/page.tsx` (NEW)

**Purpose**: Allow users to browse and add favorites without being in a room

**Features:**
- Search songs (same search as room page)
- Add to favorites directly (no room required)
- View existing favorites
- Remove favorites
- Favorites management (add, remove, view)

**API Endpoint**: `src/app/api/users/[userId]/favorites/route.ts` (update existing)
- Remove room_id requirement
- Allow favorites operations without room context

**Implementation:**
```typescript
// Standalone favorites page
export default function FavoritesPage() {
  const { karaUser } = useAuth();
  const [favorites, setFavorites] = useState<Song[]>([]);
  const [searchResults, setSearchResults] = useState([]);
  
  // Search songs (no room needed)
  const handleSearch = async (query: string) => {
    const results = await api.searchSongs({ q: query });
    setSearchResults(results);
  };
  
  // Add to favorites (no room needed)
  const handleAddFavorite = async (songId: string) => {
    await api.addFavorite(karaUser.id, songId);
    // Refresh favorites list
  };
  
  return (
    <div>
      <SearchBar onSearch={handleSearch} />
      <SearchResults results={searchResults} onAddFavorite={handleAddFavorite} />
      <FavoritesList favorites={favorites} />
    </div>
  );
}
```

### 6.3 Favorites Page (Web App Only - Foreground Playback)

**File**: `src/app/favorites/page.tsx`

**Features:**
- View user's favorites (tied to authenticated account)
- Add/remove favorites
- **Play favorites directly on user's device** (bypasses TV/display layer)
- Custom play/pause/skip controls for each favorite
- Audio plays from user's device (phone/computer speakers)
- Favorites sync across all devices via authentication

**Note**: Background audio removed from plan - YouTube iframe cannot play in background reliably. Native app moved to Phase 7 (optional, iOS share sheet only).

---

#### 6.3.1 Implementation Approach

**Concept**: Users can play favorites directly on their device without needing a TV/display connection. Each favorite has play/pause/skip controls that trigger a YouTube iframe player (minimal size, positioned off-screen) to play audio on the user's device.

**Architecture:**
- Small visible YouTube iframe player (200x200px minimum for ToS compliance)
- Positioned off-screen or in collapsible section
- Custom UI controls (play/pause/skip) trigger YouTube API calls
- Audio plays from user's device speakers (not TV)

**Reliability by Device:**
- ✅ **Desktop (Chrome/Firefox)**: 100% reliable - works after user click
- ✅ **Android Chrome**: 100% reliable - works after user click
- ✅ **iOS Safari**: ~95% reliable - works if `playVideo()` called synchronously in click handler
- ✅ **Android PWA**: 100% reliable - same as Android Chrome
- ✅ **iOS PWA**: ~95% reliable - same as iOS Safari

**Key Technical Requirements:**
1. YouTube iframe must be at least 200x200px (ToS compliance)
2. `playVideo()` must be called **synchronously** within click handler (iOS Safari requirement)
3. No async delays between click and `playVideo()` call
4. Player can be positioned off-screen but must be in DOM

---

#### 6.3.2 Component Structure

**Favorites Page Component** (`src/app/favorites/page.tsx`):

```typescript
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { YouTubePlayer } from '@/components/YouTubePlayer';
import { extractYouTubeId } from '@/lib/youtube';

interface FavoriteSong {
  id: string;
  song_id: string;
  youtube_url: string;
  title: string;
  artist: string;
  created_at: string;
}

export default function FavoritesPage() {
  const { karaUser, loading: authLoading } = useAuth();
  const [favorites, setFavorites] = useState<FavoriteSong[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentPlayingId, setCurrentPlayingId] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  
  // YouTube player refs (one per favorite, or single reusable player)
  const playerRefs = useRef<Map<string, any>>(new Map());
  const currentPlayerRef = useRef<any>(null);

  // Load favorites
  useEffect(() => {
    if (!karaUser?.id) return;
    
    async function loadFavorites() {
      try {
        const response = await fetch(`/api/users/${karaUser.id}/favorites`);
        if (response.ok) {
          const data = await response.json();
          setFavorites(data);
        }
      } catch (error) {
        console.error('Failed to load favorites:', error);
      } finally {
        setLoading(false);
      }
    }
    
    loadFavorites();
  }, [karaUser?.id]);

  // Handle play - MUST be synchronous for iOS Safari
  const handlePlay = useCallback((song: FavoriteSong) => {
    // Direct, synchronous call = works on iOS
    const player = playerRefs.current.get(song.id);
    if (player) {
      // Stop any currently playing song
      if (currentPlayerRef.current && currentPlayerRef.current !== player) {
        currentPlayerRef.current.pauseVideo();
      }
      
      // Play this song (synchronous call in click handler)
      player.playVideo();
      currentPlayerRef.current = player;
      setCurrentPlayingId(song.id);
      setIsPlaying(true);
    }
  }, []);

  // Handle pause
  const handlePause = useCallback(() => {
    if (currentPlayerRef.current) {
      currentPlayerRef.current.pauseVideo();
      setIsPlaying(false);
    }
  }, []);

  // Handle next (play next favorite)
  const handleNext = useCallback(() => {
    if (!currentPlayingId) return;
    
    const currentIndex = favorites.findIndex(f => f.id === currentPlayingId);
    if (currentIndex >= 0 && currentIndex < favorites.length - 1) {
      const nextSong = favorites[currentIndex + 1];
      handlePlay(nextSong);
    }
  }, [currentPlayingId, favorites, handlePlay]);

  // Handle player ready callback
  const handlePlayerReady = useCallback((songId: string, player: any) => {
    playerRefs.current.set(songId, player);
  }, []);

  // Handle video ended
  const handleVideoEnded = useCallback(() => {
    setCurrentPlayingId(null);
    setIsPlaying(false);
    currentPlayerRef.current = null;
    // Auto-play next if desired
    // handleNext();
  }, []);

  if (authLoading || loading) {
    return <div>Loading favorites...</div>;
  }

  if (!karaUser) {
    return <div>Please sign in to view favorites</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">My Favorites</h1>
      
      {favorites.length === 0 ? (
        <p>No favorites yet. Add songs to your favorites from the room queue.</p>
      ) : (
        <div className="space-y-4">
          {favorites.map((song) => (
            <FavoriteItem
              key={song.id}
              song={song}
              isPlaying={currentPlayingId === song.id && isPlaying}
              onPlay={() => handlePlay(song)}
              onPause={handlePause}
              onNext={handleNext}
              onPlayerReady={(player) => handlePlayerReady(song.id, player)}
              onVideoEnded={handleVideoEnded}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// Individual favorite item component
function FavoriteItem({
  song,
  isPlaying,
  onPlay,
  onPause,
  onNext,
  onPlayerReady,
  onVideoEnded,
}: {
  song: FavoriteSong;
  isPlaying: boolean;
  onPlay: () => void;
  onPause: () => void;
  onNext: () => void;
  onPlayerReady: (player: any) => void;
  onVideoEnded: () => void;
}) {
  const containerRef = useRef<HTMLDivElement>(null);
  const playerRef = useRef<any>(null);

  return (
    <div className="border rounded-lg p-4 bg-white shadow-sm">
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <h3 className="font-semibold text-lg">{song.title}</h3>
          <p className="text-gray-600">{song.artist}</p>
        </div>
        
        {/* Custom Playback Controls */}
        <div className="flex items-center gap-2">
          {isPlaying ? (
            <button
              onClick={onPause}
              className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
            >
              ⏸ Pause
            </button>
          ) : (
            <button
              onClick={onPlay}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            >
              ▶ Play
            </button>
          )}
          <button
            onClick={onNext}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            ⏭ Next
          </button>
        </div>
      </div>

      {/* Hidden but visible YouTube player (200x200px minimum for ToS) */}
      <div
        ref={containerRef}
        style={{
          width: '200px',
          height: '200px',
          position: 'absolute',
          left: '-9999px', // Off-screen but in DOM
          opacity: 0,
          pointerEvents: 'none',
        }}
      >
        <YouTubePlayer
          videoUrl={song.youtube_url}
          autoPlay={false} // Don't autoplay - user clicks play button
          controls={0} // Hide YouTube controls (we use custom controls)
          onReady={() => {
            // Get player instance and pass to parent
            if (containerRef.current) {
              const player = (window as any).YT?.Player?.getInstance?.(containerRef.current);
              if (player) {
                playerRef.current = player;
                onPlayerReady(player);
              }
            }
          }}
          onEnded={onVideoEnded}
          onStateChange={(state) => {
            // Track playing state
            if (state === 1) { // PLAYING
              // Update parent state
            } else if (state === 2) { // PAUSED
              // Update parent state
            }
          }}
        />
      </div>
    </div>
  );
}
```

---

#### 6.3.3 YouTube Player Component Updates

**Update** `src/components/YouTubePlayer.tsx` to support getting player instance:

```typescript
// Add to YouTubePlayer component
export function YouTubePlayer({ ... }: YouTubePlayerProps) {
  // ... existing code ...
  
  // Expose player instance via ref callback
  useEffect(() => {
    if (isReady && playerRef.current && onReady) {
      onReady(playerRef.current); // Pass player instance to parent
    }
  }, [isReady, onReady]);

  // ... rest of component
}
```

**Alternative**: Use a ref callback pattern to expose player instance:

```typescript
interface YouTubePlayerProps {
  // ... existing props ...
  onPlayerReady?: (player: any) => void; // New prop
}

// In component:
const handleReady = (event: any) => {
  // ... existing code ...
  if (onPlayerReady) {
    onPlayerReady(event.target); // Pass player instance
  }
};
```

---

#### 6.3.4 iOS Safari Considerations

**Critical**: For iOS Safari to work, `playVideo()` must be called **synchronously** within the click handler:

```typescript
// ✅ CORRECT - Synchronous call
const handlePlay = (song: FavoriteSong) => {
  const player = playerRefs.current.get(song.id);
  if (player) {
    player.playVideo(); // Direct call = works on iOS
  }
};

// ❌ WRONG - Async delay breaks gesture chain
const handlePlay = async (song: FavoriteSong) => {
  await someAsyncOperation(); // Breaks gesture chain!
  player.playVideo(); // Blocked on iOS
};

// ❌ WRONG - setTimeout breaks gesture chain
const handlePlay = (song: FavoriteSong) => {
  setTimeout(() => {
    player.playVideo(); // Blocked on iOS
  }, 100);
};
```

**Best Practice**: Keep all player API calls synchronous within click handlers.

---

#### 6.3.5 UI/UX Considerations

1. **Player Visibility**: 
   - Player must be at least 200x200px (YouTube ToS requirement)
   - Position off-screen (`left: -9999px`) or in collapsible section
   - Keep in DOM for API access

2. **Playback State**:
   - Show visual indicator for currently playing song
   - Disable play button when already playing
   - Show pause button when playing

3. **Error Handling**:
   - Handle YouTube API errors gracefully
   - Show user-friendly error messages
   - Allow retry on failure

4. **Loading States**:
   - Show loading indicator while player initializes
   - Disable controls until player is ready

5. **iOS-Specific Messaging** (Optional):
   - Show info message: "Tap play to start audio. Audio may start muted due to iOS restrictions."
   - Provide unmute button if needed

---

#### 6.3.6 Testing Checklist

- [ ] Desktop Chrome: Play/pause/skip works
- [ ] Desktop Firefox: Play/pause/skip works
- [ ] Android Chrome: Play/pause/skip works
- [ ] iOS Safari: Play/pause/skip works (test synchronous calls)
- [ ] Multiple favorites: Only one plays at a time
- [ ] Player positioning: Off-screen but accessible
- [ ] Error handling: YouTube errors handled gracefully
- [ ] Loading states: UI shows loading during initialization

---

#### 6.3.7 Limitations

1. **No Background Playback**: Audio stops when browser tab is inactive (expected behavior)
2. **iOS Safari Autoplay**: May require user interaction (click) to start playback (handled by play button)
3. **YouTube ToS**: Player must be visible (200x200px minimum) - positioned off-screen but in DOM
4. **Single Playback**: Only one favorite can play at a time (by design)

---

**Summary**: This implementation allows users to play favorites directly on their device, bypassing the TV/display layer. The approach uses a minimal YouTube iframe player (200x200px, off-screen) with custom controls, ensuring ToS compliance and cross-platform compatibility including iOS Safari.

---

## Phase 7: Native App (Optional - iOS Share Sheet Only)

**Installation:**
```bash
# Install Capacitor
npm install @capacitor/core @capacitor/cli @capacitor/android @capacitor/ios

# Initialize Capacitor
npx cap init "Karaoke App" "com.karaoke.app"

# Add platforms
npx cap add android
npx cap add ios
```

**Capacitor Configuration** (`capacitor.config.ts`):
```typescript
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.karaoke.app',
  appName: 'Karaoke App',
  webDir: 'out', // Next.js output directory
  server: {
    androidScheme: 'https'
  },
  plugins: {
    SplashScreen: {
      launchShowDuration: 2000,
      launchAutoHide: true
    }
  }
};

export default config;
```

**Next.js Configuration** (`next.config.js`):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // Required for Capacitor
  images: {
    unoptimized: true // Required for static export
  },
  // ... existing config
};

module.exports = nextConfig;
```

---

#### Phase 7.2: iOS Share Sheet Integration

**Install Audio Plugin:**
```bash
# No additional plugins needed for share sheet - handled via iOS configuration
```

**iOS Share Sheet Handler** (`ios/App/App/AppDelegate.swift`):
```swift
import UIKit
import Capacitor

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
  func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    // Handle share sheet URLs (YouTube links)
    NotificationCenter.default.post(name: NSNotification.Name("CAPHandleURL"), object: url)
    return true
  }
}
```

**Handle Share Sheet in App** (`src/app/page.tsx` or dedicated handler):
```typescript
import { App } from '@capacitor/app';

// Listen for app URL (from share sheet)
App.addListener('appUrlOpen', (data) => {
  const url = new URL(data.url);
  if (url.pathname.includes('youtube.com') || url.pathname.includes('youtu.be')) {
    // Extract YouTube video ID and add to queue
    const videoId = extractYouTubeId(url.href);
    // Navigate to room or add to queue
  }
});
```

---

**Note**: 
- Background audio feature removed - YouTube iframe cannot play in background
- Native app is only for iOS share sheet support (Android PWA already works)
- Favorites page is web app only (section 6.3)

**Favorites API** (`src/app/api/users/[userId]/favorites/route.ts` - update existing):
```typescript
// Allow favorites without room connection (any authenticated user can add)
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  const { song_id } = await request.json();
  
  // v5.0: Check favorites access (trial/subscription/lifetime)
  // Note: No room connection required - favorites are user-global
  if (appConfig.authMode) {
    const hasAccess = await checkFavoritesAccess(params.userId);
    
    if (!hasAccess.canSave) {
      return NextResponse.json({ 
        error: hasAccess.reason,
        upsell: hasAccess.upsell
      }, { status: 402 });
    }
  }
  
  // Add to favorites (no room_id required)
  // ... existing implementation
}
```

---

#### 7.3: Build and Deploy Process

**Development:**
```bash
# Build Next.js app
npm run build

# Copy to Capacitor
npx cap copy

# Sync native projects
npx cap sync

# Open in native IDEs (iOS only - Android PWA already works)
npx cap open ios      # Xcode
```

**Production Build:**
```bash
# 1. Build Next.js
npm run build

# 2. Copy to Capacitor
npx cap copy

# 3. Build iOS app
# iOS: Use Xcode to build IPA

# 4. Deploy to app store
# iOS: App Store Connect
# Note: Android PWA already supports share sheet, no native app needed
```

---

#### 7.4: Testing Checklist

- [ ] **iOS Share Sheet:**
  - [ ] Share sheet appears in iOS share menu
  - [ ] YouTube URLs are captured correctly
  - [ ] App opens with shared URL
  - [ ] URL is processed and added to queue

- [ ] **Android PWA (Already Works):**
  - [ ] Share-target feature works (no native app needed)
  - [ ] YouTube URLs are captured correctly

---

#### Notes

- **Background audio removed** - YouTube iframe cannot play in background reliably
- **Native app is optional** - Only needed for iOS share sheet (Android PWA already works)
- **Capacitor wrapper** allows keeping existing Next.js codebase
- **iOS share sheet** enables consistent experience with Android PWA
- **App store distribution** required only for iOS (Android can stay as PWA)

### 6.4 Pricing Page

**File**: `src/app/pricing/page.tsx`

Show pricing cards from database, integrate Stripe checkout.

### 6.5 Trial Banner Component

**File**: `src/components/FavoritesTrialBanner.tsx`

Show trial status, countdown, upsell prompts.

### 6.6 Payment Modal Component

**File**: `src/components/PaymentModal.tsx`

Handle Stripe checkout redirects.

### 6.7 Account Settings Page

**File**: `src/app/account/page.tsx`

Show subscription status, cancel subscription, purchase history.

### 6.8 UI Improvements - Better Instructions

**Files**: 
- `src/app/page.tsx` (home page)
- `src/app/room/[code]/page.tsx` (search tab)

**Home Page Instructions:**
- Replace simple host/TV/user definitions with detailed step-by-step instructions
- Step 1: Host creates room first (get room code)
- Step 2: Connect TV/display for audio (must be device connected to karaoke audio equipment)
- Step 3: Users join with room code
- Include tips and important notes about audio setup

**Search Tab Instructions:**
- **Android**: Keep existing instructions (search in-app, share to app)
- **iOS/Computer**: Add detailed step-by-step instructions:
  - Step 1: Open YouTube app/website
  - Step 2: Search for karaoke song
  - Step 3: Copy video link (with device-specific instructions)
  - Step 4: Paste link in app
  - Include visual cues and tips

**Implementation:**
```typescript
// Home page: Replace definitions section with step-by-step guide
<div style={{ /* instructions container */ }}>
  <h2>📖 How to Set Up Your Karaoke Party</h2>
  <Step number={1} title="Host Creates Room First" />
  <Step number={2} title="Connect TV/Display for Audio" />
  <Step number={3} title="Users Join with Room Code" />
</div>

// Search tab: Device-specific instructions
{isAndroid() && <AndroidInstructions />}
{(isIOS() || isDesktop()) && <IOSComputerInstructions />}
```

---

## Phase 8: Testing & Deployment

### 8.1 Feature Toggle Testing

**Test matrix:**
| AUTH_MODE | Expected Behavior |
|-----------|-------------------|
| false | v4.8: Device-based, no auth, no payments |
| true | v5.0: Auth required, payments enabled |

### 8.2 Migration Testing

1. Create device-based user in v4.8
2. Enable AUTH_MODE=true
3. Sign up with new account
4. Link device user → Verify history/favorites preserved

### 8.3 Payment Testing

Use Stripe test mode:
- Test card: `4242 4242 4242 4242`
- Test subscriptions
- Test webhooks
- Test trial expiration

### 8.4 Rollback Plan

If issues arise:
```env
NEXT_PUBLIC_AUTH_MODE=false  # Revert to v4.8
```

All v5.0 tables/columns are additive only, so v4.8 continues working.

---

## Summary

**Total new tables**: 5
- `kara_pricing`
- `kara_subscriptions`
- `kara_room_payments`
- `kara_favorites_purchases`
- `kara_favorites_trials`

**Total new columns**: 6
- `kara_rooms.payment_id`
- `kara_rooms.payment_type`
- `kara_user_preferences.subscription_id`
- `kara_user_preferences.favorites_access_type`
- `kara_user_preferences.favorites_access_expires_at`

**Total new constraints**: 1
- Unique index: 1 active room per user

**Estimated timeline**:
- Phase 1 (Toggle): 1 day
- Phase 2 (Schema): 1 day
- Phase 3 (Auth): 3 days
- Phase 4 (Stripe): 1-2 days (reuse code from existing project, adapt database tables)
  - Copy Stripe files: 0.5 days
  - Adapt database tables: 0.5 days
  - Test with new Stripe account: 0.5-1 day
- Phase 5 (Logic): 3 days
- Phase 6 (UI): 5 days
  - 6.1 Landing page with pricing & hamburger menu: 1 day
  - 6.2 Favorites without room: 1 day
  - 6.3 Favorites page (web app only): 1 day
  - 6.4-6.7 Other UI components: 2 days
  - 6.8 UI improvements (better instructions): ✅ COMPLETED
- Phase 7 (Native App - Optional): 2 days
  - 7.1 Capacitor setup: 0.5 days
  - 7.2 iOS share sheet integration: 1 day
  - 7.3 Testing: 0.5 days
- Phase 8 (Testing): 3 days
- **Total**: ~18 days (3.5 weeks) without native app, ~20 days (4 weeks) with native app

**Note on Native App:**
- **Optional** - Not required for v5.0 core functionality
- Only needed for iOS share sheet support (Android PWA already works)
- Can be done after v5.0 launch if needed
- App store submission (separate) not included in development timeline

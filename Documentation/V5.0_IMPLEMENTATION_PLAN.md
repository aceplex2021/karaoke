# v5.0 Implementation Plan: Authentication & Monetization
**Date**: 2026-01-24  
**Baseline**: v4.8 schema  
**Status**: Planning

---

## Overview

v5.0 adds user authentication and monetization while maintaining backward compatibility with v4.8. All v5.0 features are **toggle-enabled via environment variable** (`NEXT_PUBLIC_AUTH_MODE`), similar to the v4.0 transition.

**Core Features:**
1. **Authentication** - Supabase Auth (email/password, OAuth) to tie history/favorites to users and sync across all devices
2. **Monetization** - Stripe integration (subscriptions + one-time payments/a la carte)
3. **Database-driven pricing** - kara-pricing.md stored in database
4. **User-specific data** - History/favorites tied to auth user instead of device, syncs across all devices
5. **Feature toggle** - Seamless v4.8 â†” v5.0 switching
6. **Landing page** - New landing page with pricing display and hamburger menu button (top left)
7. **Favorites without room** - Ability to add to Favorites without room connection (any authenticated user)
8. **Host-only background playback** - Only hosts can play favorites in background when phone screen is off (can be implemented today with minimal UI changes)
9. **UI improvements** - Better step-by-step instructions on home page and detailed iOS/computer YouTube search instructions

---

## Completed Work (Pre-v5.0)

### Name Input Redundancy Fix (2026-01-24)

**Problem**: Users were asked to enter their name multiple times when joining rooms, inconsistently between Android and iOS/computer.

**Root Causes Identified**:
1. **localStorage key mismatch**: Join page stored name as `user_name`, but room page looked for `user_display_name`
2. **React Strict Mode**: Double execution in development caused iOS double-prompt
3. **No database fallback**: If localStorage was cleared, users had to re-enter name even if it existed in database

**Fixes Implemented**:

1. **Unified localStorage Key** (`src/app/join/page.tsx`)
   - Changed join page to store name as `user_display_name` (matching room page)
   - Result: No redundant prompt for users going through `/join` page

2. **React Strict Mode Guard** (`src/app/room/[code]/page.tsx`)
   - Added `hasCheckedNameRef` useRef guard to prevent double execution
   - Result: No double-prompt on iOS in development mode

3. **Database Fallback (Option B)** (`src/app/room/[code]/page.tsx`)
   - If name not in localStorage, check database via fingerprint
   - Uses client-side Supabase query (cost-optimized, no Vercel invocation)
   - Result: Returning users don't see modal even if localStorage cleared

4. **Backward Compatibility** (`src/app/room/[code]/page.tsx`)
   - Checks both `user_display_name` (correct) and `user_name` (legacy)
   - Result: Existing users with old key continue to work

**Files Modified**:
- `src/app/join/page.tsx` - Unified localStorage key
- `src/app/room/[code]/page.tsx` - Added React Strict Mode guard, database fallback, backward compatibility

**Cost Optimization**:
- **Original approach**: Created `/api/users/by-fingerprint/route.ts` (serverless function = Vercel invocation)
- **Optimized approach**: Use client-side Supabase query directly (0 Vercel invocations)
- **Result**: Eliminated serverless function calls for name lookup, reducing costs

**Note on `/api/users/by-fingerprint/route.ts`**:
- File exists but is **no longer used** (replaced by client-side Supabase query)
- Kept for future reference or v5.0 auth implementation
- Can be deleted if desired, or extended for v5.0 auth_user_id lookup

**Testing Checklist**:
- [x] Android: Enter name on join page â†’ Auto-joins (no modal)
- [x] iOS: Enter name on join page â†’ Auto-joins (no modal)
- [x] Direct access: Navigate to `/room/ABC123` directly â†’ Shows modal (expected)
- [x] Returning user: Leave room, rejoin same room â†’ Auto-joins (no modal)
- [x] Existing user (has `user_name` only): Works via fallback
- [x] User with localStorage cleared: Checks database â†’ Auto-joins (no modal)

**Impact on v5.0**:
- This fix prepares the app for v5.0 authentication
- With auth, names will persist across devices automatically
- Database fallback logic will work seamlessly with `auth_user_id` lookup
- No modal for returning authenticated users

---

## Phase 1: Feature Toggle & Configuration

### 1.1 Environment Variables

**Add to `.env`:**
```env
# v5.0 Authentication & Monetization Toggle
NEXT_PUBLIC_AUTH_MODE=false  # false = v4.8 (device-based), true = v5.0 (auth required)

# Stripe Configuration (only used when AUTH_MODE=true)
STRIPE_SECRET_KEY=sk_test_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Supabase Auth (already exists, but ensure enabled)
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```

### 1.2 Update Configuration File

**File**: `src/lib/config.ts`

Add v5.0 configuration alongside existing v4.0 config:

```typescript
const isAuthMode = process.env.NEXT_PUBLIC_AUTH_MODE === 'true';

export const appConfig = {
  // Existing v4.0 fields...
  commercialMode: isCommercialMode,
  
  // NEW: v5.0 Auth & Monetization
  authMode: isAuthMode,
  
  features: {
    // Existing v4.0 features...
    databaseSearch: !isCommercialMode,
    youtubeSearch: isCommercialMode,
    
    // NEW: v5.0 features (only when authMode = true)
    authentication: isAuthMode,
    monetization: isAuthMode,
    subscriptions: isAuthMode,
    userAccounts: isAuthMode,
    
    // Behavior changes based on authMode
    deviceBasedAuth: !isAuthMode,  // v4.8: fingerprint-based
    accountBasedAuth: isAuthMode,  // v5.0: Supabase Auth-based
  },
  
  // NEW: v5.0 monetization config
  monetization: {
    enabled: isAuthMode,
    favoritesTrialDays: 30,
    roomPassDurationHours: 24,
  },
  
  // NEW: v5.0 Stripe config
  stripe: {
    publishableKey: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || '',
  },
};
```

### 1.3 Add Feature Check Helper

```typescript
/**
 * Check if v5.0 features are enabled
 */
export function isV5Enabled(): boolean {
  return appConfig.authMode;
}

/**
 * Get authentication strategy
 */
export function getAuthStrategy(): 'device' | 'account' {
  return isAuthMode ? 'account' : 'device';
}
```

### 1.4 Validation

Add startup validation:
```typescript
// Validate v5.0 configuration
if (isAuthMode) {
  if (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {
    warnings.push('âš ï¸ AUTH_MODE enabled but STRIPE_PUBLISHABLE_KEY missing');
  }
  if (!process.env.STRIPE_SECRET_KEY) {
    warnings.push('âš ï¸ AUTH_MODE enabled but STRIPE_SECRET_KEY missing');
  }
}
```

---

## Phase 2: Database Schema Migration

### 2.1 Pricing Configuration Table

**Purpose**: Store pricing from kara-pricing.md in database for easy updates

**File**: `database/v5.0_pricing_table.sql`

```sql
-- Pricing configuration (loaded from kara-pricing.md)
CREATE TABLE IF NOT EXISTS kara_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_type VARCHAR(50) NOT NULL UNIQUE,  -- 'room_pass_small', 'room_pass_party', 'favorites_lifetime', 'subscription_starter_monthly', etc.
  display_name VARCHAR(255) NOT NULL,
  description TEXT,
  price_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  duration_hours INTEGER,  -- For room passes (24)
  duration_days INTEGER,   -- For trials (30)
  user_limit INTEGER,      -- Max users per room (3 for small, NULL for unlimited)
  features JSONB DEFAULT '{}',  -- Additional features as JSON
  is_active BOOLEAN DEFAULT true,
  stripe_price_id VARCHAR(255),  -- Stripe Price ID
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_pricing_product_type ON kara_pricing(product_type);
CREATE INDEX idx_pricing_is_active ON kara_pricing(is_active);

-- Initial data from kara-pricing.md
INSERT INTO kara_pricing (product_type, display_name, description, price_cents, duration_hours, user_limit) VALUES
  ('room_pass_small', 'Small Room Pass (24 hours)', 'â‰¤3 singers, host 1 room, unlimited queue', 499, 24, 3),
  ('room_pass_party', 'Party Room Pass (24 hours)', 'Unlimited singers, host controls + reorder', 1299, 24, NULL),
  ('favorites_lifetime', 'Lifetime Favorites', 'Save unlimited songs forever, one-time purchase', 999, NULL, NULL),
  ('subscription_starter_monthly', 'Starter Monthly', 'â‰¤3 singers, room hosting anytime, unlimited favorites', 499, NULL, 3),
  ('subscription_starter_yearly', 'Starter Yearly', 'â‰¤3 singers, room hosting anytime, unlimited favorites', 4999, NULL, 3),
  ('subscription_party_monthly', 'Party Monthly', 'Unlimited singers, unlimited favorites', 699, NULL, NULL),
  ('subscription_party_yearly', 'Party Yearly', 'Unlimited singers, unlimited favorites', 6999, NULL, NULL);

-- Trial configuration
INSERT INTO kara_pricing (product_type, display_name, description, price_cents, duration_days, features) VALUES
  ('favorites_trial', 'Favorites Trial', '30 days free trial for favorites', 0, 30, '{"trial": true, "auto_start": true}');
```

**Benefits:**
- Update prices without redeployment
- A/B test pricing
- Easy to add/remove tiers
- Stripe Price ID mapping

### 2.2 User Subscriptions Table

**File**: `database/v5.0_subscriptions_table.sql`

```sql
-- User subscriptions (Stripe managed)
CREATE TABLE IF NOT EXISTS kara_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_customer_id VARCHAR(255) UNIQUE,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  
  -- Subscription details
  subscription_type VARCHAR(20) NOT NULL CHECK (subscription_type IN ('starter', 'party')),
  billing_interval VARCHAR(20) NOT NULL CHECK (billing_interval IN ('monthly', 'yearly')),
  status VARCHAR(20) NOT NULL CHECK (status IN ('active', 'canceled', 'past_due', 'trialing')),
  
  -- Stripe sync fields
  current_period_start TIMESTAMPTZ NOT NULL,
  current_period_end TIMESTAMPTZ NOT NULL,
  cancel_at_period_end BOOLEAN DEFAULT false,
  canceled_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_subscriptions_user_id ON kara_subscriptions(user_id);
CREATE INDEX idx_subscriptions_stripe_customer_id ON kara_subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON kara_subscriptions(status);

COMMENT ON TABLE kara_subscriptions IS 'v5.0: User-level subscriptions (starter or party)';
COMMENT ON COLUMN kara_subscriptions.user_id IS 'One subscription per user (UNIQUE constraint)';
```

### 2.3 Room Payments Table

**File**: `database/v5.0_room_payments_table.sql`

```sql
-- One-time room payments (24-hour passes)
CREATE TABLE IF NOT EXISTS kara_room_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID NOT NULL UNIQUE REFERENCES kara_rooms(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_payment_intent_id VARCHAR(255) UNIQUE NOT NULL,
  
  -- Payment details
  payment_type VARCHAR(20) NOT NULL CHECK (payment_type IN ('room_pass_small', 'room_pass_party')),
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'succeeded', 'failed', 'refunded')),
  
  -- Room pass metadata
  expires_at TIMESTAMPTZ NOT NULL,  -- Auto-calculated: created_at + 24 hours
  user_limit INTEGER,  -- 3 for small, NULL for party
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_room_payments_room_id ON kara_room_payments(room_id);
CREATE INDEX idx_room_payments_user_id ON kara_room_payments(user_id);
CREATE INDEX idx_room_payments_status ON kara_room_payments(status);
CREATE INDEX idx_room_payments_expires_at ON kara_room_payments(expires_at);

COMMENT ON TABLE kara_room_payments IS 'v5.0: One-time 24-hour room passes';
COMMENT ON COLUMN kara_room_payments.room_id IS 'One payment per room (UNIQUE constraint)';
```

### 2.4 Favorites Purchases Table

**File**: `database/v5.0_favorites_purchases_table.sql`

```sql
-- Lifetime favorites purchases
CREATE TABLE IF NOT EXISTS kara_favorites_purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Stripe references
  stripe_payment_intent_id VARCHAR(255) UNIQUE NOT NULL,
  
  -- Purchase details
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'succeeded', 'failed', 'refunded')),
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_favorites_purchases_user_id ON kara_favorites_purchases(user_id);
CREATE INDEX idx_favorites_purchases_status ON kara_favorites_purchases(status);

COMMENT ON TABLE kara_favorites_purchases IS 'v5.0: One-time lifetime favorites purchases';
COMMENT ON COLUMN kara_favorites_purchases.user_id IS 'One purchase per user (UNIQUE constraint)';
```

### 2.5 Favorites Trial Tracking

**File**: `database/v5.0_favorites_trials_table.sql`

```sql
-- Favorites trial tracking (30-day free trial)
CREATE TABLE IF NOT EXISTS kara_favorites_trials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES kara_users(id) ON DELETE CASCADE,
  
  -- Trial lifecycle
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,  -- started_at + 30 days
  
  -- Trial status
  status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'expired', 'converted')),
  
  -- First favorite saved (triggers trial start)
  first_favorite_song_id TEXT NOT NULL,
  
  -- Conversion tracking
  converted_to VARCHAR(50),  -- 'lifetime' or 'subscription' or NULL
  converted_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_favorites_trials_user_id ON kara_favorites_trials(user_id);
CREATE INDEX idx_favorites_trials_expires_at ON kara_favorites_trials(expires_at);
CREATE INDEX idx_favorites_trials_status ON kara_favorites_trials(status);

COMMENT ON TABLE kara_favorites_trials IS 'v5.0: 30-day favorites trial tracking (auto-starts on first save)';
```

### 2.6 Update Existing Tables

**File**: `database/v5.0_update_existing_tables.sql`

```sql
-- Add payment/subscription columns to kara_rooms
ALTER TABLE kara_rooms 
  ADD COLUMN IF NOT EXISTS payment_id UUID REFERENCES kara_room_payments(id) ON DELETE SET NULL;

ALTER TABLE kara_rooms
  ADD COLUMN IF NOT EXISTS payment_type VARCHAR(20) 
  CHECK (payment_type IN ('subscription', 'room_pass', NULL));

CREATE INDEX IF NOT EXISTS idx_rooms_payment_id ON kara_rooms(payment_id);

-- Add constraint: 1 active room per user
CREATE UNIQUE INDEX IF NOT EXISTS idx_rooms_one_active_per_user 
  ON kara_rooms(host_id) WHERE is_active = true;

-- Add subscription fields to kara_user_preferences
ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS subscription_id UUID REFERENCES kara_subscriptions(id) ON DELETE SET NULL;

ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS favorites_access_type VARCHAR(20)
  CHECK (favorites_access_type IN ('trial', 'lifetime', 'subscription', NULL));

ALTER TABLE kara_user_preferences
  ADD COLUMN IF NOT EXISTS favorites_access_expires_at TIMESTAMPTZ;

CREATE INDEX IF NOT EXISTS idx_user_prefs_subscription_id ON kara_user_preferences(subscription_id);
CREATE INDEX IF NOT EXISTS idx_user_prefs_favorites_access ON kara_user_preferences(favorites_access_type, favorites_access_expires_at);

COMMENT ON COLUMN kara_user_preferences.favorites_access_type IS 'How user has favorites access: trial, lifetime purchase, or subscription';
COMMENT ON COLUMN kara_user_preferences.favorites_access_expires_at IS 'NULL for lifetime, timestamp for trial/subscription';
```

---

## Phase 3: Authentication System

### 3.1 Supabase Auth Setup

**Goal**: Enable email/password + OAuth (Google, etc.)

#### 3.1.1 Enable Auth in Supabase Dashboard
1. Go to Authentication â†’ Providers
2. Enable Email/Password
3. Enable Google OAuth (optional)
4. Configure redirect URLs:
   - `http://localhost:3000/auth/callback` (dev)
   - `https://yourdomain.com/auth/callback` (prod)

#### 3.1.2 Auth Context Provider

**File**: `src/contexts/AuthContext.tsx`

```typescript
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { User as SupabaseUser } from '@supabase/supabase-js';
import { supabaseClient } from '@/lib/supabase-client';
import { User } from '@/shared/types';
import { appConfig } from '@/lib/config';

interface AuthContextType {
  supabaseUser: SupabaseUser | null;
  karaUser: User | null;
  loading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, displayName: string) => Promise<void>;
  signOut: () => Promise<void>;
  signInWithGoogle: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [supabaseUser, setSupabaseUser] = useState<SupabaseUser | null>(null);
  const [karaUser, setKaraUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // Only initialize if AUTH_MODE is enabled
  const isEnabled = appConfig.authMode;

  useEffect(() => {
    if (!isEnabled) {
      setLoading(false);
      return;
    }

    // Get initial session
    supabaseClient.auth.getSession().then(({ data: { session } }) => {
      setSupabaseUser(session?.user ?? null);
      if (session?.user) {
        loadKaraUser(session.user.id);
      } else {
        setLoading(false);
      }
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabaseClient.auth.onAuthStateChange((_event, session) => {
      setSupabaseUser(session?.user ?? null);
      if (session?.user) {
        loadKaraUser(session.user.id);
      } else {
        setKaraUser(null);
        setLoading(false);
      }
    });

    return () => subscription.unsubscribe();
  }, [isEnabled]);

  async function loadKaraUser(authUserId: string) {
    try {
      const response = await fetch(`/api/users/by-auth/${authUserId}`);
      if (response.ok) {
        const data = await response.json();
        setKaraUser(data.user);
      }
    } catch (error) {
      console.error('Failed to load kara user:', error);
    } finally {
      setLoading(false);
    }
  }

  async function signIn(email: string, password: string) {
    const { error } = await supabaseClient.auth.signInWithPassword({
      email,
      password,
    });
    if (error) throw error;
  }

  async function signUp(email: string, password: string, displayName: string) {
    // 1. Create Supabase auth user
    const { data, error } = await supabaseClient.auth.signUp({
      email,
      password,
      options: {
        data: {
          display_name: displayName,
        },
      },
    });
    if (error) throw error;

    // 2. Create kara_users entry
    if (data.user) {
      await fetch('/api/users/create-from-auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          auth_user_id: data.user.id,
          display_name: displayName,
          email: data.user.email,
        }),
      });
    }
  }

  async function signOut() {
    await supabaseClient.auth.signOut();
  }

  async function signInWithGoogle() {
    await supabaseClient.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`,
      },
    });
  }

  return (
    <AuthContext.Provider
      value={{
        supabaseUser,
        karaUser,
        loading,
        signIn,
        signUp,
        signOut,
        signInWithGoogle,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 3.2 Auth Pages

#### 3.2.1 Login Page

**File**: `src/app/login/page.tsx`

```typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import { appConfig } from '@/lib/config';

export default function LoginPage() {
  const router = useRouter();
  const { signIn, signInWithGoogle, loading } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  // Redirect to home if AUTH_MODE is disabled
  if (!appConfig.authMode) {
    router.push('/');
    return null;
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError('');
    try {
      await signIn(email, password);
      router.push('/');
    } catch (err: any) {
      setError(err.message || 'Failed to sign in');
    }
  }

  async function handleGoogleSignIn() {
    try {
      await signInWithGoogle();
    } catch (err: any) {
      setError(err.message || 'Failed to sign in with Google');
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h1 className="text-2xl font-bold mb-6 text-center">Sign In to Kara</h1>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
          >
            {loading ? 'Signing In...' : 'Sign In'}
          </button>
        </form>

        <div className="mt-4">
          <button
            onClick={handleGoogleSignIn}
            disabled={loading}
            className="w-full bg-white border border-gray-300 text-gray-700 py-2 rounded-lg hover:bg-gray-50"
          >
            Sign In with Google
          </button>
        </div>

        <p className="mt-4 text-center text-sm">
          Don't have an account?{' '}
          <a href="/signup" className="text-blue-600 hover:underline">
            Sign Up
          </a>
        </p>
      </div>
    </div>
  );
}
```

#### 3.2.2 Signup Page

**File**: `src/app/signup/page.tsx` (similar structure, calls `signUp`)

### 3.3 Migration Strategy: Device â†’ Account

**Goal**: Smoothly migrate existing device-based users to account-based users

#### 3.3.1 Linking API Endpoint

**File**: `src/app/api/users/link-device-to-account/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/server/lib/supabase';

/**
 * POST /api/users/link-device-to-account
 * Links existing device-based user to authenticated account
 */
export async function POST(request: NextRequest) {
  try {
    const { auth_user_id, fingerprint } = await request.json();

    // Find existing device-based user
    const { data: deviceUser } = await supabaseAdmin
      .from('kara_users')
      .select('*')
      .eq('fingerprint', fingerprint)
      .single();

    if (deviceUser) {
      // Link existing user to auth account
      await supabaseAdmin
        .from('kara_users')
        .update({ auth_user_id })
        .eq('id', deviceUser.id);

      return NextResponse.json({ 
        success: true, 
        user: { ...deviceUser, auth_user_id },
        message: 'History and favorites preserved' 
      });
    } else {
      // Create new user with auth_user_id
      const { data: newUser } = await supabaseAdmin
        .from('kara_users')
        .insert({ auth_user_id, fingerprint })
        .select()
        .single();

      return NextResponse.json({ 
        success: true, 
        user: newUser,
        message: 'New account created' 
      });
    }
  } catch (error) {
    console.error('Link device to account error:', error);
    return NextResponse.json({ error: 'Failed to link account' }, { status: 500 });
  }
}
```

#### 3.3.2 Auto-Prompt on First Login

When user signs in for the first time, check for device fingerprint and offer to link:

```typescript
// In AuthContext after successful login
const fingerprint = localStorage.getItem('user_fingerprint');
if (fingerprint) {
  await fetch('/api/users/link-device-to-account', {
    method: 'POST',
    body: JSON.stringify({ auth_user_id: session.user.id, fingerprint }),
  });
}
```

---

## Phase 4: Stripe Integration

### 4.1 Install Dependencies

```bash
npm install stripe @stripe/stripe-js
```

### 4.2 Stripe Server Client

**File**: `src/server/lib/stripe.ts`

```typescript
import Stripe from 'stripe';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('Missing STRIPE_SECRET_KEY');
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2024-12-18.acacia',
  typescript: true,
});
```

### 4.3 Stripe Client (Frontend)

**File**: `src/lib/stripe-client.ts`

```typescript
import { loadStripe } from '@stripe/stripe-js';
import { appConfig } from './config';

let stripePromise: Promise<any> | null = null;

export function getStripe() {
  if (!appConfig.monetization.enabled) {
    return null;
  }

  if (!stripePromise) {
    stripePromise = loadStripe(appConfig.stripe.publishableKey);
  }
  return stripePromise;
}
```

### 4.4 Pricing API Endpoints

#### 4.4.1 Get Pricing

**File**: `src/app/api/pricing/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/server/lib/supabase';
import { appConfig } from '@/lib/config';

/**
 * GET /api/pricing
 * Returns active pricing from database
 */
export async function GET() {
  // Return empty if monetization disabled
  if (!appConfig.monetization.enabled) {
    return NextResponse.json({ pricing: [] });
  }

  const { data: pricing, error } = await supabaseAdmin
    .from('kara_pricing')
    .select('*')
    .eq('is_active', true)
    .order('price_cents', { ascending: true });

  if (error) {
    return NextResponse.json({ error: 'Failed to fetch pricing' }, { status: 500 });
  }

  return NextResponse.json({ pricing });
}
```

#### 4.4.2 Create Checkout Session

**File**: `src/app/api/payments/create-checkout/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { stripe } from '@/server/lib/stripe';
import { supabaseAdmin } from '@/server/lib/supabase';

/**
 * POST /api/payments/create-checkout
 * Create Stripe checkout session for subscriptions or one-time payments
 */
export async function POST(request: NextRequest) {
  try {
    const { product_type, user_id, success_url, cancel_url } = await request.json();

    // Get pricing from database
    const { data: pricing } = await supabaseAdmin
      .from('kara_pricing')
      .select('*')
      .eq('product_type', product_type)
      .single();

    if (!pricing) {
      return NextResponse.json({ error: 'Invalid product type' }, { status: 400 });
    }

    // Create Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      mode: product_type.includes('subscription') ? 'subscription' : 'payment',
      line_items: [
        {
          price_data: {
            currency: pricing.currency.toLowerCase(),
            product_data: {
              name: pricing.display_name,
              description: pricing.description,
            },
            unit_amount: pricing.price_cents,
            ...(product_type.includes('subscription') && {
              recurring: {
                interval: product_type.includes('monthly') ? 'month' : 'year',
              },
            }),
          },
          quantity: 1,
        },
      ],
      success_url,
      cancel_url,
      metadata: {
        user_id,
        product_type,
      },
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error('Create checkout error:', error);
    return NextResponse.json({ error: 'Failed to create checkout' }, { status: 500 });
  }
}
```

### 4.5 Stripe Webhooks

**File**: `src/app/api/webhooks/stripe/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { stripe } from '@/server/lib/stripe';
import { supabaseAdmin } from '@/server/lib/supabase';
import Stripe from 'stripe';

/**
 * POST /api/webhooks/stripe
 * Handle Stripe webhooks (payment completed, subscription updated, etc.)
 */
export async function POST(request: NextRequest) {
  const body = await request.text();
  const signature = request.headers.get('stripe-signature');

  if (!signature) {
    return NextResponse.json({ error: 'No signature' }, { status: 400 });
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err: any) {
    console.error('Webhook signature verification failed:', err.message);
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
  }

  // Handle different event types
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
      break;
    case 'customer.subscription.updated':
      await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
      break;
    case 'customer.subscription.deleted':
      await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
      break;
    case 'payment_intent.succeeded':
      await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent);
      break;
  }

  return NextResponse.json({ received: true });
}

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const { user_id, product_type } = session.metadata || {};
  
  if (!user_id || !product_type) return;

  if (product_type.includes('subscription')) {
    // Create subscription record
    await supabaseAdmin.from('kara_subscriptions').insert({
      user_id,
      stripe_customer_id: session.customer as string,
      stripe_subscription_id: session.subscription as string,
      subscription_type: product_type.includes('party') ? 'party' : 'starter',
      billing_interval: product_type.includes('monthly') ? 'monthly' : 'yearly',
      status: 'active',
      current_period_start: new Date(),
      current_period_end: new Date(Date.now() + (product_type.includes('monthly') ? 30 : 365) * 24 * 60 * 60 * 1000),
    });
  } else if (product_type === 'favorites_lifetime') {
    // Create favorites purchase
    await supabaseAdmin.from('kara_favorites_purchases').insert({
      user_id,
      stripe_payment_intent_id: session.payment_intent as string,
      amount_cents: session.amount_total || 0,
      status: 'succeeded',
    });
    
    // Update user preferences
    await supabaseAdmin
      .from('kara_user_preferences')
      .upsert({
        user_id,
        favorites_access_type: 'lifetime',
        favorites_access_expires_at: null,
      }, { onConflict: 'user_id' });
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  await supabaseAdmin
    .from('kara_subscriptions')
    .update({
      status: subscription.status,
      current_period_end: new Date(subscription.current_period_end * 1000),
      cancel_at_period_end: subscription.cancel_at_period_end,
    })
    .eq('stripe_subscription_id', subscription.id);
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  await supabaseAdmin
    .from('kara_subscriptions')
    .update({ status: 'canceled', canceled_at: new Date() })
    .eq('stripe_subscription_id', subscription.id);
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  // Handle one-time payments (room passes, favorites lifetime)
  // Update payment status in database
}
```

---

## Phase 5: Business Logic & Enforcement

### 5.1 Room Creation with Payment Check

**File**: `src/app/api/rooms/create/route.ts` (update existing)

```typescript
export async function POST(request: NextRequest) {
  const { room_name, host_fingerprint, host_display_name } = await request.json();
  
  // v5.0: Check if AUTH_MODE is enabled
  if (appConfig.authMode) {
    // AUTH_MODE: Require authentication
    const authHeader = request.headers.get('authorization');
    if (!authHeader) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }
    
    // Extract user from JWT
    const user = await getUserFromToken(authHeader);
    
    // Check if user has active subscription or valid room pass
    const hasAccess = await checkRoomAccess(user.id);
    if (!hasAccess) {
      return NextResponse.json({ 
        error: 'Payment required',
        redirect: '/pricing'
      }, { status: 402 });
    }
    
    // Check: Only 1 active room per user
    const { data: existingRoom } = await supabaseAdmin
      .from('kara_rooms')
      .select('id')
      .eq('host_id', user.id)
      .eq('is_active', true)
      .single();
    
    if (existingRoom) {
      return NextResponse.json({ 
        error: 'You already have an active room. Close it first.',
        room_id: existingRoom.id
      }, { status: 400 });
    }
    
    // Create room...
  } else {
    // v4.8 mode: Device-based (existing logic)
    // ... existing room creation code
  }
}

async function checkRoomAccess(userId: string): Promise<boolean> {
  // Check active subscription
  const { data: subscription } = await supabaseAdmin
    .from('kara_subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .single();
  
  if (subscription) return true;
  
  // Check valid room pass (not expired)
  const { data: roomPass } = await supabaseAdmin
    .from('kara_room_payments')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'succeeded')
    .gt('expires_at', new Date().toISOString())
    .single();
  
  return !!roomPass;
}
```

### 5.2 Favorites Access Check

**File**: `src/app/api/users/[userId]/favorites/route.ts` (update existing)

```typescript
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  const { song_id } = await request.json();
  
  // v5.0: Check favorites access (any authenticated user can add, no room required)
  if (appConfig.authMode) {
    const hasAccess = await checkFavoritesAccess(params.userId);
    
    if (!hasAccess.canSave) {
      return NextResponse.json({ 
        error: hasAccess.reason,
        upsell: hasAccess.upsell
      }, { status: 402 });
    }
  }
  
  // Add to favorites (no room_id required - can add without room connection)
  // Note: Room context is optional, favorites are user-global
  // Background playback is host-only (checked separately in playback endpoint)
}

async function checkFavoritesAccess(userId: string) {
  // Check lifetime purchase
  const { data: lifetime } = await supabaseAdmin
    .from('kara_favorites_purchases')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'succeeded')
    .single();
  
  if (lifetime) {
    return { canSave: true, canAdd: true };
  }
  
  // Check active subscription
  const { data: subscription } = await supabaseAdmin
    .from('kara_subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .single();
  
  if (subscription) {
    return { canSave: true, canAdd: true };
  }
  
  // Check trial
  const { data: trial } = await supabaseAdmin
    .from('kara_favorites_trials')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .gt('expires_at', new Date().toISOString())
    .single();
  
  if (trial) {
    return { canSave: true, canAdd: true, trial: true };
  }
  
  // No access
  return { 
    canSave: false, 
    canAdd: false,
    reason: 'Favorites trial expired',
    upsell: {
      lifetime: 999,
      subscription_monthly: 499
    }
  };
}
```

### 5.3 Trial Auto-Start

**File**: `src/app/api/users/[userId]/favorites/start-trial/route.ts`

```typescript
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  try {
    const { first_favorite_song_id } = await request.json();
    
    // Check if trial already exists
    const { data: existing } = await supabaseAdmin
      .from('kara_favorites_trials')
      .select('*')
      .eq('user_id', params.userId)
      .single();
    
    if (existing) {
      return NextResponse.json({ trial: existing });
    }
    
    // Create 30-day trial
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30);
    
    const { data: trial } = await supabaseAdmin
      .from('kara_favorites_trials')
      .insert({
        user_id: params.userId,
        first_favorite_song_id,
        expires_at: expiresAt.toISOString(),
        status: 'active',
      })
      .select()
      .single();
    
    return NextResponse.json({ 
      trial,
      message: 'Favorites Trial Started ðŸŽ‰',
      days_remaining: 30
    });
  } catch (error) {
    console.error('Start trial error:', error);
    return NextResponse.json({ error: 'Failed to start trial' }, { status: 500 });
  }
}
```

---

## Phase 6: Frontend UI Components

### 6.1 Landing Page with Pricing

**File**: `src/app/page.tsx` (update existing)

**Features:**
- **Hamburger menu button** (top left) - Navigation menu with:
  - Home
  - Pricing
  - Account/Settings (if authenticated)
  - Login/Signup (if not authenticated)
  - Logout (if authenticated)
- **Pricing display** - Show pricing cards directly on landing page
  - Room passes (Small/Party)
  - Subscriptions (Starter/Party, Monthly/Yearly)
  - Lifetime Favorites
- **Call-to-action buttons** - "Get Started", "View Pricing", etc.
- **Responsive design** - Mobile-friendly layout

**Implementation:**
```typescript
// Hamburger menu component
<HamburgerMenu>
  <MenuItem href="/">Home</MenuItem>
  <MenuItem href="/pricing">Pricing</MenuItem>
  {isAuthenticated ? (
    <>
      <MenuItem href="/account">Account</MenuItem>
      <MenuItem onClick={signOut}>Logout</MenuItem>
    </>
  ) : (
    <>
      <MenuItem href="/login">Login</MenuItem>
      <MenuItem href="/signup">Sign Up</MenuItem>
    </>
  )}
</HamburgerMenu>

// Pricing section on landing page
<PricingSection>
  <PricingCard type="room_pass_small" />
  <PricingCard type="room_pass_party" />
  <PricingCard type="subscription_starter_monthly" />
  <PricingCard type="subscription_party_monthly" />
  <PricingCard type="favorites_lifetime" />
</PricingSection>
```

### 6.2 Favorites Without Room Connection

**File**: `src/app/favorites/page.tsx` (NEW)

**Purpose**: Allow users to browse and add favorites without being in a room

**Features:**
- Search songs (same search as room page)
- Add to favorites directly (no room required)
- View existing favorites
- Remove favorites
- Background playback (host-only, see 6.5)

**API Endpoint**: `src/app/api/users/[userId]/favorites/route.ts` (update existing)
- Remove room_id requirement
- Allow favorites operations without room context

**Implementation:**
```typescript
// Standalone favorites page
export default function FavoritesPage() {
  const { karaUser } = useAuth();
  const [favorites, setFavorites] = useState<Song[]>([]);
  const [searchResults, setSearchResults] = useState([]);
  
  // Search songs (no room needed)
  const handleSearch = async (query: string) => {
    const results = await api.searchSongs({ q: query });
    setSearchResults(results);
  };
  
  // Add to favorites (no room needed)
  const handleAddFavorite = async (songId: string) => {
    await api.addFavorite(karaUser.id, songId);
    // Refresh favorites list
  };
  
  return (
    <div>
      <SearchBar onSearch={handleSearch} />
      <SearchResults results={searchResults} onAddFavorite={handleAddFavorite} />
      <FavoritesList favorites={favorites} />
    </div>
  );
}
```

### 6.3 Host-Only Background Playback

**File**: `src/app/favorites/page.tsx` (update)

**Features:**
- **Background playback (host-only)** - Only hosts can play favorites in background when phone screen is off
- **Playback controls** - Play/pause, skip, volume controls (available to all users)
- **Queue management** - Play favorites in sequence
- **Lock screen controls** - Media controls on lock screen (host-only)

**Implementation:**
```typescript
// Check if user is host
const { karaUser } = useAuth();
const isHost = await checkIfHost(karaUser.id);

// Background playback setup (Web Audio API + Service Worker)
if (isHost) {
  // Enable background playback
  const audioContext = new AudioContext();
  
  // Service Worker for background playback
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw-audio.js');
  }
  
  // Media Session API for lock screen controls
  if ('mediaSession' in navigator) {
    navigator.mediaSession.setActionHandler('play', () => audioContext.resume());
    navigator.mediaSession.setActionHandler('pause', () => audioContext.suspend());
  }
}

// Play favorites in background
const playFavorite = async (song: Song) => {
  const audio = new Audio(song.media_url);
  audio.play();
  
  // Keep playing when screen locks
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Continue playback in background
      audio.play();
    }
  });
};
```

**Service Worker**: `public/sw-audio.js`
```javascript
// Service Worker for background audio playback
self.addEventListener('message', (event) => {
  if (event.data.type === 'PLAY_AUDIO') {
    // Handle background audio playback
  }
});
```

**API Endpoint**: `src/app/api/users/[userId]/favorites/route.ts`
```typescript
// Allow favorites without room connection (any authenticated user can add)
export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  const { song_id } = await request.json();
  
  // v5.0: Check favorites access (trial/subscription/lifetime)
  // Note: No room connection required - favorites are user-global
  if (appConfig.authMode) {
    const hasAccess = await checkFavoritesAccess(params.userId);
    
    if (!hasAccess.canSave) {
      return NextResponse.json({ 
        error: hasAccess.reason,
        upsell: hasAccess.upsell
      }, { status: 402 });
    }
  }
  
  // Add to favorites (no room_id required)
}
```

**Background Playback Check** (separate endpoint):
```typescript
// Check if user can play favorites in background (host-only)
export async function GET(request: NextRequest, { params }: { params: { userId: string } }) {
  // Check if user is host (has active room)
  const { data: activeRoom } = await supabaseAdmin
    .from('kara_rooms')
    .select('*')
    .eq('host_id', params.userId)
    .eq('is_active', true)
    .single();
  
  return NextResponse.json({ 
    canPlayBackground: !!activeRoom,
    isHost: !!activeRoom
  });
}
```

### 6.4 Pricing Page

**File**: `src/app/pricing/page.tsx`

Show pricing cards from database, integrate Stripe checkout.

### 6.5 Trial Banner Component

**File**: `src/components/FavoritesTrialBanner.tsx`

Show trial status, countdown, upsell prompts.

### 6.6 Payment Modal Component

**File**: `src/components/PaymentModal.tsx`

Handle Stripe checkout redirects.

### 6.7 Account Settings Page

**File**: `src/app/account/page.tsx`

Show subscription status, cancel subscription, purchase history.

### 6.8 UI Improvements - Better Instructions

**Files**: 
- `src/app/page.tsx` (home page)
- `src/app/room/[code]/page.tsx` (search tab)

**Home Page Instructions:**
- Replace simple host/TV/user definitions with detailed step-by-step instructions
- Step 1: Host creates room first (get room code)
- Step 2: Connect TV/display for audio (must be device connected to karaoke audio equipment)
- Step 3: Users join with room code
- Include tips and important notes about audio setup

**Search Tab Instructions:**
- **Android**: Keep existing instructions (search in-app, share to app)
- **iOS/Computer**: Add detailed step-by-step instructions:
  - Step 1: Open YouTube app/website
  - Step 2: Search for karaoke song
  - Step 3: Copy video link (with device-specific instructions)
  - Step 4: Paste link in app
  - Include visual cues and tips

**Implementation:**
```typescript
// Home page: Replace definitions section with step-by-step guide
<div style={{ /* instructions container */ }}>
  <h2>ðŸ“– How to Set Up Your Karaoke Party</h2>
  <Step number={1} title="Host Creates Room First" />
  <Step number={2} title="Connect TV/Display for Audio" />
  <Step number={3} title="Users Join with Room Code" />
</div>

// Search tab: Device-specific instructions
{isAndroid() && <AndroidInstructions />}
{(isIOS() || isDesktop()) && <IOSComputerInstructions />}
```

---

## Phase 7: Testing & Deployment

### 7.1 Feature Toggle Testing

**Test matrix:**
| AUTH_MODE | Expected Behavior |
|-----------|-------------------|
| false | v4.8: Device-based, no auth, no payments |
| true | v5.0: Auth required, payments enabled |

### 7.2 Migration Testing

1. Create device-based user in v4.8
2. Enable AUTH_MODE=true
3. Sign up with new account
4. Link device user â†’ Verify history/favorites preserved

### 7.3 Payment Testing

Use Stripe test mode:
- Test card: `4242 4242 4242 4242`
- Test subscriptions
- Test webhooks
- Test trial expiration

### 7.4 Rollback Plan

If issues arise:
```env
NEXT_PUBLIC_AUTH_MODE=false  # Revert to v4.8
```

All v5.0 tables/columns are additive only, so v4.8 continues working.

---

## Summary

**Total new tables**: 5
- `kara_pricing`
- `kara_subscriptions`
- `kara_room_payments`
- `kara_favorites_purchases`
- `kara_favorites_trials`

**Total new columns**: 6
- `kara_rooms.payment_id`
- `kara_rooms.payment_type`
- `kara_user_preferences.subscription_id`
- `kara_user_preferences.favorites_access_type`
- `kara_user_preferences.favorites_access_expires_at`

**Total new constraints**: 1
- Unique index: 1 active room per user

**Estimated timeline**:
- Phase 1 (Toggle): 1 day
- Phase 2 (Schema): 1 day
- Phase 3 (Auth): 3 days
- Phase 4 (Stripe): 3 days
- Phase 5 (Logic): 3 days
- Phase 6 (UI): 7 days
  - 6.1 Landing page with pricing & hamburger menu: 1 day
  - 6.2 Favorites without room: 1 day
  - 6.3 Host-only favorites with background playback: 2 days
  - 6.4-6.7 Other UI components: 2 days
  - 6.8 UI improvements (better instructions): 1 day
- Phase 7 (Testing): 3 days
- **Total**: ~20 days (4 weeks)
